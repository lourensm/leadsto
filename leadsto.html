<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>LeadsTo Software</title>
<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white"> 
<div class="title">LeadsTo Software</div>
<div class="author">Lourens van der Meij <br>
E-mail: <a class="url" href="mailto:lourenstcc@gmail.com">lourenstcc@gmail.com</a></div>
<div class="abstract">
<div class="abstract-title">Abstract</div> This document describes the 
LeadsTo software in detail. It starts out as an investigation into 
details of the algorithm.

<p></div>

<h1><a id="document-contents">Table of Contents</a></h1>

<div class="toc">
<div class="toc-h2"><a class="sec" href="#sec:1"><span class="sec-nr">1</span> <span class="sec-title">LeadsTo 
core design and implementation</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.1"><span class="sec-nr">1.1</span> <span class="sec-title">Introduction</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.2"><span class="sec-nr">1.2</span> <span class="sec-title">run_simulation/2</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:1.3"><span class="sec-nr">1.3</span> <span class="sec-title">LeadsTo 
specifications</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:1.3.1"><span class="sec-nr">1.3.1</span> <span class="sec-title">Sources 
for information</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:2"><span class="sec-nr">2</span> <span class="sec-title">Details</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:2.1"><span class="sec-nr">2.1</span> <span class="sec-title">Times: 
Handled Time, Setup Time, Start Time, End Time</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:2.2"><span class="sec-nr">2.2</span> <span class="sec-title">Traces</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:2.2.1"><span class="sec-nr">2.2.1</span> <span class="sec-title">Datastructures</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:2.2.2"><span class="sec-nr">2.2.2</span> <span class="sec-title">Algorithm 
Variables</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:2.2.3"><span class="sec-nr">2.2.3</span> <span class="sec-title">Loading 
and Trace Generation</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:2.2.4"><span class="sec-nr">2.2.4</span> <span class="sec-title">Saving 
traces</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:3"><span class="sec-nr">3</span> <span class="sec-title">Details</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.1"><span class="sec-nr">3.1</span> <span class="sec-title">Constants</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.2"><span class="sec-nr">3.2</span> <span class="sec-title">Model 
Checking</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.3"><span class="sec-nr">3.3</span> <span class="sec-title">recwait</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.4"><span class="sec-nr">3.4</span> <span class="sec-title">Following 
the progress of leadsto rules</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:4"><span class="sec-nr">4</span> <span class="sec-title">Working 
backwards</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.1"><span class="sec-nr">4.1</span> <span class="sec-title">Leadsto 
times <code>e</code>, <code>f</code>, <code>g</code>, <code>h</code></span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.2"><span class="sec-nr">4.2</span> <span class="sec-title">Invariant</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.3"><span class="sec-nr">4.3</span> <span class="sec-title">Sketch 
of the algorithm</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.4"><span class="sec-nr">4.4</span> <span class="sec-title">Rule 
States</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.5"><span class="sec-nr">4.5</span> <span class="sec-title">Garbage 
collection</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.6"><span class="sec-nr">4.6</span> <span class="sec-title">Runtime 
Algorithm Predicates</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:5"><span class="sec-nr">5</span> <span class="sec-title">wait 
entries</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:5.1"><span class="sec-nr">5.1</span> <span class="sec-title">wait</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:6"><span class="sec-nr">6</span> <span class="sec-title">So 
far</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:7"><span class="sec-nr">7</span> <span class="sec-title">"Syntax" 
of Leadsto Specifications</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:8"><span class="sec-nr">8</span> <span class="sec-title">TODO</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:8.1"><span class="sec-nr">8.1</span> <span class="sec-title">waitvar, 
waitfired</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:8.1.1"><span class="sec-nr">8.1.1</span> <span class="sec-title">Debugging, 
verifying waitvar FV,FVL aspects</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:8.2"><span class="sec-nr">8.2</span> <span class="sec-title">Solving 
bugje-nondeterminism</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:8.3"><span class="sec-nr">8.3</span> <span class="sec-title">analyse 
case</span></a></div>
</div>

<p>

<h2><a id="sec:1"><span class="sec-nr">1</span> <span class="sec-title">LeadsTo 
core design and implementation</span></a></h2>

<p>

<h3><a id="sec:1.1"><span class="sec-nr">1.1</span> <span class="sec-title">Introduction</span></a></h3>

<p>A leadsto specification is encoded as a pl file containing 
predicates.

<p>

<h3><a id="sec:1.2"><span class="sec-nr">1.2</span> <span class="sec-title">run_simulation/2</span></a></h3>

<p>Here we describe the main leadsto procedure <a id="idx:runsimulation2:1"></a><span class="pred-ext">run_simulation/2</span>,
<code>run_simulation(File, Frame)</code> This leadsto specification <var>File</var> 
is loaded into the leadsto runtime:

<p>
<ol class="latex">
<li>The predicates are loaded into module <code>spec</code>.

<p>
<li>After that, all terms in the input file are preprocessed, often 
leading to asserted dynamic predicates in the current(algo) module.

<p>There seems to be almost no compilation at this stage and it looks 
like terms in thee spec module often are asserted as facts into algo 
without any transformation.

<p>Some translation of sortdefs is performed. If a sort contains less 
than 100 ground terms, it is instantiated, otherwise the sort definition 
is left as is. This leads to spec:sortdef(Sort, Terms). The source 
contains a beginning of a new way of encoding sort definitions.

<p>
<li>If the specification contained a model specification, we run each 
model instance after setting up model parameters. Otherwise we perform a 
single run.

<p>
<li>Running the specification

<p>
<ol class="latex">
<li>setup of the runtime (first part of <a id="idx:runspec10:2"></a><a class="pred" href="#runspec1/0">runspec1/0</a>)
<li>performing the firing of rules (<a id="idx:runspecrest0:3"></a><span class="pred-ext">runspec_rest/0</span>)
</ol>

<p>
<li>Saving the generated trace
</ol>

<p>

<h3><a id="sec:1.3"><span class="sec-nr">1.3</span> <span class="sec-title">LeadsTo 
specifications</span></a></h3>

<p>

<h4><a id="sec:1.3.1"><span class="sec-nr">1.3.1</span> <span class="sec-title">Sources 
for information</span></a></h4>

<p>The file <code>userman.html</code> contains the documentation for 
most allowed constructs in LeadsTo specifications.

<p>The file <code>olddoc/syntax.txt</code> also describes the syntax. 
See <a class="sec" href="#sec:7">section 7</a>.

<p>

<h2><a id="sec:2"><span class="sec-nr">2</span> <span class="sec-title">Details</span></a></h2>

<p>

<h3><a id="sec:2.1"><span class="sec-nr">2.1</span> <span class="sec-title">Times: 
Handled Time, Setup Time, Start Time, End Time</span></a></h3>

<dl class="latex">
<dt><b>setuptime, <code>TSetup</code></b></dt>
<dd>
In practice identical to <code>TStartup</code>, but there are options 
for defining <code>TSetup</code> to have a value before
<code>TStart</code> so that leadsto rules could fire for antecedent 
values before
<code>TStart</code> and use <code>cwa(Atom)</code> derived values to 
make them fire. The current value of <code>TSetup</code> is stored in
<code>dyn_setup_time(TSetup)</code>.&nbsp;<sup class="fn">1<span class="fn-text"> 
We had command line options <code>setup_maxg</code> and <code>setup_maxfg</code> 
for that purpose that would introduce <code>TSetup</code> based on the 
maximum leadsto rule values for <em>f</em> and <em>g</em>. But the 
sourcecode says this is not supported. So, in practice <code>TStart == 
TSetup</code></span></sup>
</dd>
<dt><b>handledtime</b></dt>
<dd>
Handled time is initialized by <a id="idx:setupunknownorcwa2:4"></a><span class="pred-ext">setup_unknown_or_cwa/2</span> 
to TStart. There is an additional implied condition on handled time: 
"You should never ask for values before TSetup" and "All atoms that have 
no explicit trace entry before THandled have value false if cwa, unknown 
otherwise".
</dd>
<dt><b>starttime, <code>TStart</code></b></dt>
<dd>
Start time. The algorithm uses <code>TSetup</code>, but <code>TStart</code> 
still plays a role, when storing traces, only values at/after <code>TStart</code> 
are saved.&nbsp;<sup class="fn">2<span class="fn-text">TODO:check this!</span></sup>
<code>TStart</code> is stored as
<code>dyn_start_time(TStart)</code>, but only called through <a id="idx:starttime1:5"></a><span class="pred-ext">start_time/1</span>.</dd>
<dt><b>endtime</b></dt>
<dd>
If not specified there currently is a default of 200 (see <a id="idx:endtime1:6"></a><span class="pred-ext">end_time/1</span>)
</dd>
</dl>

<p><code>TSetup</code> and <code>TSetup</code> are set up in
<code>do_setup_time(TStart, TSetup)</code>. They may contain 
specification constants.&nbsp;<sup class="fn">3<span class="fn-text">In <a id="idx:dosetuptimes2:7"></a><span class="pred-ext">do_setup_times/2</span> 
the values are passed through <code>tr_basic_element(Term, [], TermOut)</code> 
that will substitute <code>spec:constant(Name, Val)</code> occurrences. 
See <a class="sec" href="#sec:3.1">section 3.1</a>.</span></sup>

<p><code>HandledTime</code> is incremented in <a id="idx:handledtimestep1:8"></a><span class="pred-ext">handled_time_step/1</span> 
and
<a id="idx:runspecrest0:9"></a><span class="pred-ext">runspec_rest/0</span> 
ensures that at the end of the leadsto algorithm <code>HandledTime &gt;= 
Endtime</code>.

<p>

<h3><a id="sec:2.2"><span class="sec-nr">2.2</span> <span class="sec-title">Traces</span></a></h3>

<p>

<h4><a id="sec:2.2.1"><span class="sec-nr">2.2.1</span> <span class="sec-title">Datastructures</span></a></h4>

<p>Traces are stored as Prolog facts, each fact represents values of a 
single ground atom.

<p>Values of an atom over time are represented as a list:

<pre class="code">
[range(23.0, 24.0, true), range(17, 18, true)]
</pre>

<p>The ranges are ordered, the latest time range first. During the 
execution of our leadsto algorithm, only necessary values are stored, 
unknown ranges or false ranges where <code>cwa(Atom)</code> holds are 
not part of the trace.

<p>Traces are generated by the main algorithm in module algo. They are 
internally stored as <code>dyn_atom_trace(AtomKey, Atom, AtomTrace)</code> 
facts. For performance reasoning traces that can no longer play a role 
in the algorithm are backed up into
<a id="idx:dynatomtracebackup3:10"></a><a class="pred" href="#dyn_atom_trace_backup/3">dyn_atom_trace_backup/3</a> 
facts.&nbsp;<sup class="fn">4<span class="fn-text">TODO:I seem to 
remember that at places in the algorithm we depend on there either being <a id="idx:dynatomtrace3:11"></a><a class="pred" href="#dyn_atom_trace/3">dyn_atom_trace/3</a> 
or <a id="idx:dynatomtracebackup3:12"></a><a class="pred" href="#dyn_atom_trace_backup/3">dyn_atom_trace_backup/3</a>.</span></sup>

<p>In saved traces all values are represented. Saved traces will only 
contain atom values in the range <code>start_time</code> to <code>end_time</code>. 
The leadsto algorithm may derive values outside of that range.&nbsp;<sup class="fn">5<span class="fn-text"> 
TODO: We should discuss alternatives: 
<ol class="latex">
<li>Why not save only necessary values in saved traces? 
<li>If saving everything, why not compact the timerange? <code>[range(T1, 
T2, TFU1), range(T2, T3, TFU3), ...]</code> into <code>[T1-TFU1, 
T2-TFU2, .. TE-[]]</code> 
</ol>
</span></sup>

<p><a id="idx:filledatomtrace3:13"></a><a class="pred" href="#filled_atom_trace/3">filled_atom_trace/3</a> 
and <a id="idx:atomtrace3:14"></a><a class="pred" href="#atom_trace/3">atom_trace/3</a> 
are probably only used for saving and printing out results.

<dl class="latex">
<dt class="pubdef"><a id="dyn_atom_trace/3"><strong>dyn_atom_trace</strong>(<var>AtomKey, 
Atoma, AtomTrace</var>)</a></dt>
<dt class="pubdef"><a id="dyn_atom_trace_backup/3"><strong>dyn_atom_trace_backup</strong>(<var>AtomKey, 
Atoma, AtomTrace</var>)</a></dt>
<dt class="pubdef"><a id="atom_trace/3"><strong>atom_trace</strong>(<var>AtomKey, 
Atoma, AtomTrace</var>)</a></dt>
<dd class="defbody">
Looks for both <a id="idx:dynatomtrace3:15"></a><a class="pred" href="#dyn_atom_trace/3">dyn_atom_trace/3</a> 
facts and <a id="idx:dynatomtracebackup3:16"></a><a class="pred" href="#dyn_atom_trace_backup/3">dyn_atom_trace_backup/3</a> 
facts.
</dd>
<dt class="pubdef"><a id="filled_atom_trace/3"><strong>filled_atom_trace</strong>(<var>AtomKey, 
Atoma, AtomTrace</var>)</a></dt>
<dd class="defbody">
Same as <a id="idx:atomtrace3:17"></a><a class="pred" href="#atom_trace/3">atom_trace/3</a>, 
but fills in cwa values up to <code>EndTime</code>
</dd>
<dt class="pubdef"><a id="find_atom_trace/2"><strong>find_atom_trace</strong>(<var>?Atom, 
+AtomTrace</var>)</a></dt>
<dd class="defbody">
Only looks for <a id="idx:dynatomtrace3:18"></a><a class="pred" href="#dyn_atom_trace/3">dyn_atom_trace/3</a> 
facts, not <a id="idx:dynatomtracebackup3:19"></a><a class="pred" href="#dyn_atom_trace_backup/3">dyn_atom_trace_backup/3</a>.
</dd>
<dt class="pubdef"><a id="atom_key/2"><strong>atom_key</strong>(<var>+Atom, 
?AtomKey</var>)</a></dt>
<dd class="defbody">
Returns <var>AtomKey</var> given <var>Atom</var>. <var>Atom</var> must 
be <code>ground</code>. The predicate defines the relationship by means 
of
<code>term_to_atom(Atom, AtomKey)</code>; there are problems with this 
way of defining the hash-value. I seem to remember that floating point 
numbers could give wrong results?
</dd>
</dl>

<p>The <var>AtomKey</var> - <var>Atoma</var> pairs

<p>

<h4><a id="sec:2.2.2"><span class="sec-nr">2.2.2</span> <span class="sec-title">Algorithm 
Variables</span></a></h4>

<dl class="latex">
<dt class="pubdef"><a id="dyn_sim_status/2"><strong>dyn_sim_status</strong>(<var>File, 
Status</var>)</a></dt>
<dd class="defbody">
says in what stage of loading and running the algo algorithm is. <var>Status</var> 
is <code>loaded</code>, <code>running</code> or <code>done</code>.</dd>
<dt class="pubdef"><a id="dyn_currently_loaded/2"><strong>dyn_currently_loaded</strong>(<var>Kind, 
File</var>)</a></dt>
<dd class="defbody">
says what <var>File</var> is loaded and what <var>Kind</var>, where <var>Kind</var> 
is <code>trace</code> or
<code>sim</code>.
</dd>
</dl>

<p>

<h4><a id="sec:2.2.3"><span class="sec-nr">2.2.3</span> <span class="sec-title">Loading 
and Trace Generation</span></a></h4>

<dl class="latex">
<dt class="pubdef"><a id="load_simulation/1"><strong>load_simulation</strong>(<var>+File</var>)</a></dt>
<dd class="defbody">
The specification <var>File</var> is loaded into module <code>spec</code>. 
The source code seems somewhat complex: The module <code>spec</code> is 
set up,
<a id="idx:discontinous1:20"></a><span class="pred-ext">discontinous/1</span> 
directives are generated for all leadsto specification terms, the terms 
are read from <var>File</var> and asserted one by one into the <code>spec</code> 
module.

<p>Command line constants are added to module spec (see <a class="sec" href="#sec:3.1">section 
3.1</a>).

<p>Then, the leadsto specification is read one more time, and each <code>Term</code> 
is passed on to <a id="idx:handleterm1:21"></a><span class="pred-ext">handle_term/1</span>. 
Most terms are handled by asserting dynamic facts into module <code>algo</code>. 
Some of those are 1-1 translations, others are not.

<p><code>model(Model)</code> is translated into <code>dyn_model(Model)</code>, 
after checking that there is only one such term.

<p><code>cwa(F/A)</code> is translated into <code>dyn_cwa(FunctorTerm)</code>.

<p>The most interesting things happen with interval leadsto 
specification terms and leadsto rule terms. Interval rules are converted 
into two standard forms and stored by <a id="idx:initialiseinterval3:22"></a><a class="pred" href="#initialise_interval/3">initialise_interval/3</a> 
and
<a id="idx:initialiseintervalperiodic4:23"></a><a class="pred" href="#initialise_interval_periodic/4">initialise_interval_periodic/4</a>.

<p><a id="idx:handleterm1:24"></a><span class="pred-ext">handle_term/1</span> 
itself simply assertz leadsto rules into
<code>dyn_leadsto(RuleId, Vars, Antecedent, Consequent, Delay)</code> 
facts.
<a id="idx:setupleadsto6:25"></a><a class="pred" href="#setup_leadsto/6">setup_leadsto/6</a> 
processes these facts further in <a id="idx:runspec10:26"></a><a class="pred" href="#runspec1/0">runspec1/0</a> 
at algorithm startup.

<p>Finally <a id="idx:updatesorts0:27"></a><span class="pred-ext">update_sorts/0</span> 
performs some pre compilation of sort definitions.
<sup class="fn">6<span class="fn-text"> TODO: It is unclear what happens 
to sortdefs at this stage. Questions are: 
<ul class="latex">
<li>What terms are used? Are they spec:sortdef/2 and spec:sortdef/4? 
<li>What is the role of <a id="idx:dynsortdef5:28"></a><span class="pred-ext">dyn_sortdef/5</span>? 
<li>Are constants somehow substituted into sortdef elements? 
</ul>
Question surrounding <a id="idx:loadsimulation1:29"></a><a class="pred" href="#load_simulation/1">load_simulation/1</a>: 
<ul class="latex">
<li>Why is the leadsto specification scanned twice. The terms will be 
probably be walked through even one more time to set up the algorithm. 
</ul>
</span></sup></dd>
<dt class="pubdef"><a id="initialise_interval/3"><strong>initialise_interval</strong>(<var>+Range, 
+Vars, +LiteralConjunction</var>)</a></dt>
<dd class="defbody">
Handles initial setup of all non-periodic interval rules. In this phase 
the predicate asserts <code>dyn_interval(i(Range, Vars, 
LiteralConjunction)</code>.
<a id="idx:setuprtintervals0:30"></a><a class="pred" href="#setup_rt_intervals/0">setup_rt_intervals/0</a> 
processes the terms further at algorithm startup.
</dd>
<dt class="pubdef"><a id="initialise_interval_periodic/4"><strong>initialise_interval_periodic</strong>(<var>+Range, 
+Period, +Vars, +LiteralConjunction</var>)</a></dt>
<dd class="defbody">
the predicate asserts <code>dyn_interval(i(Range, Period, Vars, 
LiteralConjunction)</code>.
<a id="idx:setuprtintervals0:31"></a><a class="pred" href="#setup_rt_intervals/0">setup_rt_intervals/0</a> 
processes the terms further in <a id="idx:runspec10:32"></a><a class="pred" href="#runspec1/0">runspec1/0</a> 
at algorithm startup.
<a id="idx:initialiseinterval3:33"></a><a class="pred" href="#initialise_interval/3">initialise_interval/3</a> 
and <a id="idx:initialiseintervalperiodic4:34"></a><a class="pred" href="#initialise_interval_periodic/4">initialise_interval_periodic/4</a> 
deal with them.

<p>Leadsto rule terms are translated into
<code>dyn_leadsto(I, Vars, LitDisConj, AndLiterals, Delay)</code> facts.

<p><a id="idx:loadsimulation1:35"></a><a class="pred" href="#load_simulation/1">load_simulation/1</a> 
sets <code>dyn_sim_status(File, loaded)</code>.</dd>
<dt class="pubdef"><a id="reset_sim_info/0"><strong>reset_sim_info</strong></a></dt>
<dd class="defbody">
clears the content of spec together with other run time information.
</dd>
<dt class="pubdef"><a id="runshowspec/1"><strong>runshowspec</strong>(<var>+Frame</var>)</a></dt>
<dd class="defbody">
Two parts, <a id="idx:runspecdo1:36"></a><a class="pred" href="#runspecdo/1">runspecdo/1</a> 
and <a id="idx:showresults2:37"></a><span class="pred-ext">show_results/2</span>.</dd>
<dt class="pubdef"><a id="runspecdo/1"><strong>runspecdo</strong>(<var>+Frame</var>)</a></dt>
<dd class="defbody">
(Functionality in <a id="idx:runspec1:38"></a><span class="pred-ext">runspec/1</span>). 
If we are dealing with a model, we initialize the output trace common to 
all model traces, then for each model instantiation we call <a id="idx:runmodel4:39"></a><span class="pred-ext">runmodel/4</span> 
that does
<a id="idx:runspec10:40"></a><a class="pred" href="#runspec1/0">runspec1/0</a> 
and cleans up after itself for the next <a id="idx:runmodel4:41"></a><span class="pred-ext">runmodel/4</span>.

<p>If there is no <a id="idx:model1:42"></a><span class="pred-ext">model/1</span>, 
we call <a id="idx:runspec10:43"></a><a class="pred" href="#runspec1/0">runspec1/0</a> 
followed by <a id="idx:savetrace1:44"></a><span class="pred-ext">savetrace/1</span>.</dd>
<dt class="pubdef"><a id="runspec1/0"><strong>runspec1</strong></a></dt>
<dd class="defbody">
This procedure calls <a id="idx:dosetuptime2:45"></a><span class="pred-ext">do_setup_time/2</span> 
that sets up <code>TSetup</code> and
<code>TStart</code>.

<p>In <a id="idx:runspec1:46"></a><span class="pred-ext">runspec/1</span> 
we perform:
<a id="idx:setuprtintervals0:47"></a><a class="pred" href="#setup_rt_intervals/0">setup_rt_intervals/0</a>, <a id="idx:setupunknownorcwa2:48"></a><span class="pred-ext">setup_unknown_or_cwa/2</span>, <a id="idx:setupleadsto6:49"></a><a class="pred" href="#setup_leadsto/6">setup_leadsto/6</a> 
for each leadsto rule
<a id="idx:dynleadsto5:50"></a><span class="pred-ext">dyn_leadsto/5</span>, <a id="idx:getmodelcheckingprules0:51"></a><span class="pred-ext">get_model_checking_p_rules/0</span> 
(??), <a id="idx:setupatomstateboundaries0:52"></a><span class="pred-ext">setup_atom_state_boundaries/0</span> 
and finally do the real reasoning in <a id="idx:runspecrest0:53"></a><span class="pred-ext">runspec_rest/0</span>.</dd>
<dt class="pubdef"><a id="setup_rt_intervals/0"><strong>setup_rt_intervals</strong></a></dt>
<dd class="defbody">
For every <a id="idx:dyninterval1:54"></a><span class="pred-ext">dyn_interval/1</span> 
term we perform <a id="idx:initintervalcallbacks10:55"></a><a class="pred" href="#init_interval_callbacks/10">init_interval_callbacks/10</a> 
where all but the first three arguments are callback variables or 
callback predicates.

<p>The setting of the interval rules does some detailed steps such as 
variable instantiation. Finally this leads to changes to <a id="idx:dynatomtrace3:56"></a><a class="pred" href="#dyn_atom_trace/3">dyn_atom_trace/3</a>. 
See

<pre class="code">
initialise_interval_p(Interval, P, Vars, Form1) :-
        (       instantiate_vars(Vars, VarsInst),
                tr_range(Interval, VarsInst, T1, T2),
                tr_basic_element(P, VarsInst, P1),
                ...
</pre>

</dd>
<dt class="pubdef"><a id="setup_leadsto/6"><strong>setup_leadsto</strong>(<var>+TStart, 
+Vars, +Antecedent, +Consequent, +Delay, +RId</var>)</a></dt>
<dd class="defbody">
(Called by <a id="idx:runspec10:57"></a><a class="pred" href="#runspec1/0">runspec1/0</a>). 
It translates and transforms the rule using <a id="idx:initintervalcallbacks10:58"></a><a class="pred" href="#init_interval_callbacks/10">init_interval_callbacks/10</a>, 
then calls <a id="idx:setupltinternalL5:59"></a><span class="pred-ext">setup_lt_internalL/5</span> 
which simply calls <a id="idx:setupltinternal6:60"></a><span class="pred-ext">setup_lt_internal/6</span>. 
That predicate simplifies Antecedent and Consequent terms using
<a id="idx:simplifyterm4:61"></a><span class="pred-ext">simplify_term/4</span>. 
In some cases the rules simplify to specifying constant Antecedents. 
Other cases are passed on to <a id="idx:setupnontrivialleadsto5:62"></a><span class="pred-ext">setup_nontrivial_leadsto/5</span>. 
It stores the compiled leadsto rule as
<code>dyn_lt_rule(Id, AnteLits,ConseRId,PVOutC,Delay,RId)</code> but 
also does initial firing and instantiation the leadsto rule data 
structures by calling <a id="idx:setuplt6:63"></a><a class="pred" href="#setup_lt/6">setup_lt/6</a> 
which calls <a id="idx:setupltnormed8:64"></a><a class="pred" href="#setup_lt_normed/8">setup_lt_normed/8</a> 
with argument
<code>Removed = initial</code> , which is part of the run time 
algorithm.</dd>
<dt class="pubdef"><a id="init_interval_callbacks/10"><strong>init_interval_callbacks</strong>(<var>TmInf, 
Vars, Forms, TmInf1, Vars1, Forms2, InvldVars, InvldTimeInfo, 
ActPreInsttiated</var>)</a></dt>
<dd class="defbody">
is used for setting up interval rules and leadsto rules. It instantiates 
variables, also takes care of <a id="idx:forall2:65"></a><span class="pred-ext">forall/2</span> 
terms( instantiates them).

<p></dd>
</dl>

<p>

<h4><a id="sec:2.2.4"><span class="sec-nr">2.2.4</span> <span class="sec-title">Saving 
traces</span></a></h4>

<p>Traces are saved in two stages by

<dl class="latex">
<dt class="pubdef"><a id="savetracesetup/3"><strong>savetracesetup</strong>(<var>+File, 
+Frame, -Telling</var>)</a></dt>
<dd class="defbody">
Saves constants and sets up trace storage stream.
</dd>
<dt class="pubdef"><a id="savetrace1/1"><strong>savetrace1</strong>(<var>+TraceName</var>)</a></dt>
<dd class="defbody">
Saves the trace itself. (If <var>TraceName</var> is <code>[]</code>, 
trace will not have trace id.)
</dd>
<dt class="pubdef"><a id="savemodelspec_cleanup/2"><strong>savemodelspec_cleanup</strong>(<var>-TellStream, 
+ModelInstanceTraceName</var>)</a></dt>
<dd class="defbody">
If the <em>leadsto specification</em> contains a model, the separate 
model instances saved.
</dd>
</dl>

<p>

<h2><a id="sec:3"><span class="sec-nr">3</span> <span class="sec-title">Details</span></a></h2>

<p><h3 id="sec:constants"><a id="sec:3.1"><span class="sec-nr">3.1</span> <span class="sec-title">Constants</span></a></h3>

<a id="sec:constants"></a>

<p>One can define <em>specification constants</em> constants that will 
be substituted into leadsto specification elements. Within a leadsto 
specification we use:

<pre class="code">
constant(Name, Value).
</pre>

<p>From the command line one can specify <code>-constant Name=Value</code>. 
This adds a constant to the specification. Value must be a valid ground 
Prolog term.

<p><code>set_option_constant/1</code> handles this by asserting <code>dyn_add_cmd_constant/2</code>.

<p>util:load_cmd_constants/0 loads those constants into module <code>spec</code> 
as
<code>constant(Name, Value)</code> facts.

<p>Constants are substituted by the procedure
<code>tr_basic_element(Term, [], TermOut)</code>. Constants are stored 
as
<code>spec:constant(Name, Val)</code> values.

<p><h3 id="sec:modelchecking"><a id="sec:3.2"><span class="sec-nr">3.2</span> <span class="sec-title">Model 
Checking</span></a></h3>

<a id="sec:modelchecking"></a>

<p>The source contains code labelled <em>model checking</em>. I do not 
remember whether this code ever worked. I seem to remember I tried 
converting the leadsto model into some state based form.

<p><code>Makefile</code> contains an example call of using 
modelchecking:

<pre class="code">
./leadsto -local -modelchecking spec/heartn.lt
</pre>

<p>The only visible result seems to be some debugging info on the 
screen.

<p>A first look at the code in <em>modelchecking.pl</em> does not make 
anything clear yet.

<p>There is a document <code>olddocs/modelchecking.doc</code> that may 
provide background. I fear that the code that is still present in <code>algo.pl</code> 
never really did anything.

<p>

<h3><a id="sec:3.3"><span class="sec-nr">3.3</span> <span class="sec-title">recwait</span></a></h3>

<p>Within algo the two choices for representing algorithm state are 
mixed too much with the rest of the code. <a id="idx:recwait0:66"></a><span class="pred-ext">recwait/0</span> 
is the switch between storage as recorded and storage as a dynamic 
clause. Sometimes code seems to be copy/pasted. But, it seems that 
backtracking in the recorded database and backtracking in the asserted 
database works differently, see <a id="idx:updateactivitytimes11:67"></a><span class="pred-ext">update_activity_times1/1</span>.

<p>

<h3><a id="sec:3.4"><span class="sec-nr">3.4</span> <span class="sec-title">Following 
the progress of leadsto rules</span></a></h3>

<p>We start with <a id="idx:setupleadsto6:68"></a><a class="pred" href="#setup_leadsto/6">setup_leadsto/6</a> 
where the arguments are almost identical to the values in the Leadsto 
specification.

<dl class="latex">
<dt class="pubdef"><a id="setup_leadsto/6"><strong>setup_leadsto</strong>(<var>TStart, 
Vars, LitDisConj, AndLiterals, Delay,RId</var>)</a></dt>
<dd class="defbody">
where the arguments are almost identical to the values in the Leadsto 
specification. Then <a id="idx:initintervalcallbacks9:69"></a><span class="pred-ext">init_interval_callbacks/9</span> 
transforms some constructs such as forall.

<p>After a number of steps involving normalizing conjunctions and 
disjunctions&nbsp;<sup class="fn">7<span class="fn-text">TODO:Verify 
whether disjunction is allowed</span></sup> and partial evaluation 
pruning out true and false results, <a id="idx:setuplt6:70"></a><a class="pred" href="#setup_lt/6">setup_lt/6</a> 
is called.</dd>
<dt class="pubdef"><a id="setup_lt/6"><strong>setup_lt</strong>(<var>Ante, 
Conse, Vars, Delay, Id, RId</var>)</a></dt>
<dd class="defbody">

<p>The encoding of the antecedent is responsible for generating code. If 
a Term is a comparison operator, code is generated for that, if a term 
is an arithmetic expression, code is also generated.

<p>We pass on some (incomplete) data structures within <a id="idx:setuplt6:71"></a><a class="pred" href="#setup_lt/6">setup_lt/6</a>. <a id="idx:codeform4:72"></a><a class="pred" href="#code_form/4">code_form/4</a> 
uses
<code>ds_d(AnteResult, VarsIn, PVIn)</code> and <code>ds_d(AnteTail, 
VarsOut, PVOut)</code>.
<code>AnteResult</code> is a difference list. Therefore often <code>AnteTail</code> 
is set to <code>[]</code>.

<p><a id="idx:setuplt6:73"></a><a class="pred" href="#setup_lt/6">setup_lt/6</a> 
calls <a id="idx:setupltnormed8:74"></a><a class="pred" href="#setup_lt_normed/8">setup_lt_normed/8</a>. 
The result is stored as
<code>dyn_lt_rule(Id, AnteLits,ConseRId,PVOutC,Delay,RId)</code> but 
more important, <a id="idx:setupltnormed8:75"></a><a class="pred" href="#setup_lt_normed/8">setup_lt_normed/8</a> 
is called, it leads to <a id="idx:setupltwaitvar12:76"></a><a class="pred" href="#setup_lt_wait_var/12">setup_lt_wait_var/12</a>.</dd>
<dt class="pubdef"><a id="code_form/4"><strong>code_form</strong>(<var>+AnteConse, 
+PosNeg:[pos, neg], DIn, DOut</var>)</a></dt>
<dd class="defbody">

<p><a id="idx:codeform4:77"></a><a class="pred" href="#code_form/4">code_form/4</a> 
is used for <code>Ante</code> and <code>Conse</code>.

<p>Each <code>AnteConseTerm</code> is translated as a list element in <code>AnteResult</code>.
<code>L = ds_litd(Atom, PosNeg, PreOps, PostOps, PostConds)</code> where
<code>Atom</code> can be true or any other value. It seems that its 
translated value is not tested in any way.

<p>Within <a id="idx:codeform4:78"></a><a class="pred" href="#code_form/4">code_form/4</a>, <code>tr_arg_prolog1(Term, 
PVIn, Term1, Inst, DSTAIn, DSTAOut)</code> is used where

<pre class="code">
DSTAIn = ds_ta(VIn, PVIn, [], [], []),
...
DSTAOut = ds_ta(VOut, PVOut, PreOpsOut, PostOpsOut, PostCondsOut),
</pre>

<p>Inst should result in <code>Inst == inst</code>.</dd>
<dt class="pubdef"><a id="tr_arg_prolog1/6"><strong>tr_arg_prolog1</strong>(<var>Term, 
PVIn, Term1, Inst, DSTAIn, DSTAOut</var>)</a></dt>
<dd class="defbody">

<p><a id="idx:trargprolog16:79"></a><a class="pred" href="#tr_arg_prolog1/6">tr_arg_prolog1/6</a> 
translates leadsto variables into Prolog variables, their relationship 
is stored and retrieved in <code>PVIn/PVOut</code>, by
<a id="idx:varpltovarlist6:80"></a><span class="pred-ext">var_pl_to_var_list/6</span> 
and <a id="idx:varplfromvarlist5:81"></a><span class="pred-ext">var_pl_from_var_list/5</span>.

<p>The first encounter of a leadsto variable in a <a id="idx:codeform4:82"></a><a class="pred" href="#code_form/4">code_form/4</a> 
has
<code>Inst= next</code>, a later one gets <code>Inst = inst</code>. Inst 
values can be <code>inst</code>,
<code>next</code>, <code>var</code>, <code>mixed</code>.

<p><a id="idx:trargprolog16:83"></a><a class="pred" href="#tr_arg_prolog1/6">tr_arg_prolog1/6</a> 
is also responsible for substituting
<em>spec_constant</em>s.&nbsp;<sup class="fn">8<span class="fn-text">TODO: 
Check whether Atoms could end up as Prolog variables, look at <a id="idx:codeatom4:84"></a><span class="pred-ext">code_atom/4</span> 
where <code>Inst</code> is ignored in the code. Can <code>Inst</code> be <code>var</code> 
or <code>mixed</code> there?</span></sup></dd>
<dt class="pubdef"><a id="code_conse/6"><strong>code_conse</strong>(<var>Conse, 
VOut, PVOut, Id, ConseRId, PVOutC</var>)</a></dt>
<dd class="defbody">
translates
<code>Conse</code> through <a id="idx:codeform4:85"></a><a class="pred" href="#code_form/4">code_form/4</a>, 
but true <code>ConseLits</code> are removed.&nbsp;<sup class="fn">9<span class="fn-text">(TODO: 
why not from Ante?).</span></sup>

<p>The consequent is encoded as <code>ds_cr(ConseLits, ds_ri(Id))</code>, 
but pxor consequents are treated differently.&nbsp;<sup class="fn">10<span class="fn-text">TODO</span></sup>.
</dd>
</dl>

<p>TODO: Looking at the code, it seems that we do not reorder the <code>AnteLiterals</code> 
depending on intermediate results.

<p>

<h2><a id="sec:4"><span class="sec-nr">4</span> <span class="sec-title">Working 
backwards</span></a></h2>

<p>Meaning, trying to reconstruct the algorithm from the start.

<p>

<h3><a id="sec:4.1"><span class="sec-nr">4.1</span> <span class="sec-title">Leadsto 
times <code>e</code>, <code>f</code>, <code>g</code>, <code>h</code></span></a></h3>

<p>We limited <code>e</code>, <code>f</code>,
<code>g</code>, <code>h</code>:<code>e,f, g, h &gt;= 0</code> and if <code>h 
== 0</code> then
<code>g</code> must be 0. But also,
<code>e + f + g + h &gt; 0</code>.&nbsp;<sup class="fn">11<span class="fn-text">Why 
those requirements? We probably do not want to reason without delay.</span></sup>

<p><code>e, f, g, h</code>:

<p>Once an antecedent holds for duration <code>g + T</code>, a delay is 
set between <code>e</code> and
<code>f</code>, and the antecedent will hold during <code>h + T</code>. 
So, even if a rule has fired, we need to remember that it has fired and 
as long as the antecedent may continue to hold, the consequent will be 
propagated for a longer time.

<p>

<h3><a id="sec:4.2"><span class="sec-nr">4.2</span> <span class="sec-title">Invariant</span></a></h3>

<p><code>HandledTime</code>: Everything that can be derived, has been 
derived for
<code>T &lt;= HandledTime</code>. CWA atom values do not have to be 
instantiated, probably will not be instantiated to false values.

<p>

<h3><a id="sec:4.3"><span class="sec-nr">4.3</span> <span class="sec-title">Sketch 
of the algorithm</span></a></h3>

<p>All rules that could still fire are inspected, their antecedent 
effect is exhaustively tested up to <code>HandledTime</code> at least.

<p>After everything has fired, we inspect all waiting antecedents, and 
look at time their first result could come in. And the minimum value 
becomes the next
<code>HandledTime</code>, unless this minimum value is not after <code>HandledTime</code> 
(could it be smaller?). It looks like the algorithm currently simply 
gives up if there is a rule that could fire at
<code>HandledTime</code>.

<p>It is probably important that together with setting <code>HandledTime</code>, 
every rule that has some continuation has its effect propagated till the 
new <code>HandledTime</code>.

<p>This would make the invariant more precise: Every rule has its state 
updated in such a way that the antecedents have been checked up to the 
new <code>HandledTime</code>.

<p>

<h3><a id="sec:4.4"><span class="sec-nr">4.4</span> <span class="sec-title">Rule 
States</span></a></h3>

<p>Rules can contain variables, that is, antecedent literals can have 
variables. There can be more than one separate state per rule.

<p>It could be that the first N literals of the antecedent with some 
specific instantiation are valid in some time range <code>T1 - T2</code>.

<p>We will look strictly left to right.

<p>But, the extending of the fired rules is done in reverse, why? 
Probably because we wish to extend the range as far as possible.

<p>

<h3><a id="sec:4.5"><span class="sec-nr">4.5</span> <span class="sec-title">Garbage 
collection</span></a></h3>

<p>Is complex and not documented. In the source some explanation is 
given,
<code>olddocs/bugdev.txt</code> also contains some explanation.

<p><a id="idx:dynhandledwaitvarinstance4:86"></a><span class="pred-ext">dyn_handled_wait_var_instance/4</span> 
is complex, asserted in <a id="idx:markhandled7:87"></a><span class="pred-ext">mark_handled/7</span>.
<a id="idx:markhandled7:88"></a><span class="pred-ext">mark_handled/7</span> 
is only called in <a id="idx:rmgcwaitvars18:89"></a><span class="pred-ext">rm_gc_wait_vars1/8</span>.

<p>In <a id="idx:failfilterhandle15:90"></a><span class="pred-ext">fail_filter_handle/15</span> 
a comment says "ignoring handled instance" and then indeed skips 
handling the <code>FV</code> instantiation.

<p>In <a id="idx:instantiateop16:91"></a><span class="pred-ext">instantiate_op/16</span> 
we skip <a id="idx:setupltnormed8:92"></a><a class="pred" href="#setup_lt_normed/8">setup_lt_normed/8</a> 
if we encountered the matching <a id="idx:dynhandledwaitvarinstance4:93"></a><span class="pred-ext">dyn_handled_wait_var_instance/4</span>.

<p>Another fact: <a id="idx:dynrmgcwaitvars8:94"></a><span class="pred-ext">dyn_rm_gc_wait_vars/8</span>. 
But that seems clear:assertion takes place only in <a id="idx:rmgcwaitvars8:95"></a><span class="pred-ext">rm_gc_wait_vars/8</span> 
and depends on the <code>postpone_rm_gc</code> option being set. The 
entries are handled by <a id="idx:postponedrmgc0:96"></a><span class="pred-ext">postponed_rm_gc/0</span> 
where indeed the postponed entries are handled by <a id="idx:rmgcwaitvars18:97"></a><span class="pred-ext">rm_gc_wait_vars1/8</span>.

<p><a id="idx:postponedrmgc0:98"></a><span class="pred-ext">postponed_rm_gc/0</span> 
is called at the end of <a id="idx:updateactivitytimes1:99"></a><span class="pred-ext">update_activity_times/1</span>. 
This seems to be harmless?

<p>We should at least make sure that a duplicate handling of a <code>wait_var</code> 
entry does not lead to erraneous results. That could be the case if we 
would derive another delay if <code>e &lt; f</code>. We need to be able 
to detect such situations!

<p>

<h3><a id="sec:4.6"><span class="sec-nr">4.6</span> <span class="sec-title">Runtime 
Algorithm Predicates</span></a></h3>

<dl class="latex">
<dt class="pubdef"><a id="setup_lt_normed/8"><strong>setup_lt_normed</strong>(<var>AnteTODO, 
AnteHolds, TMin, THolds, ConseRId,PV, Delay, Removed</var>)</a></dt>
<dd class="defbody">
We know AnteHolds holds in range <var>TMin</var>, <var>THolds</var>, we 
need to continue with <var>AnteTODO</var>. AnteHolds has all Prolog 
variables instantiated and excluded from <code>FVL</code> wait_var 
occurrences.

<p>If <var>AnteTODO</var> becomes <code>[]</code>, <br>
<code>setup_lt_conse(AnteHolds, TMin, THolds, ConseRId, Delay, Removed)</code> 
is called. Otherwise, <a id="idx:setupltnotground9:100"></a><span class="pred-ext">setup_lt_notground/9</span> 
is called which calls
<a id="idx:setupltnotgroundfv13:101"></a><a class="pred" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a> 
after setting up the free variable arguments.</dd>
<dt class="pubdef"><a id="setup_lt_conse/6"><strong>setup_lt_conse</strong>(<var>AnteHolds, 
TMin, THolds, ConseRId, Delay, Removed</var>)</a></dt>
<dd class="defbody">
We know The whole antecedent holds between <var>TMin</var> and <var>THolds</var>. 
If <code>THolds &gt;= TMin + G</code>, we calculate
<code>T3 is TMin + G + Delay</code> and
<code>T4 is THolds + Delay + H</code> and then call
<code>schedule_fire(ConseRId, T3, T4)</code> which sets
<code>dyn_schedule_fire(ConseRId, T3, T4)</code>.&nbsp;<sup class="fn">12<span class="fn-text">I 
left out details dealing with pxor aspects. What is the reason for <a id="idx:schedulefire3:102"></a><span class="pred-ext">schedule_fire/3</span>, 
why postpone?</span></sup> They are fired by the <code>repeat, 
set_state, handle_fired</code> sequence in
<a id="idx:runspecrest0:103"></a><span class="pred-ext">runspec_rest/0</span>.&nbsp;<sup class="fn">13<span class="fn-text">Why 
not fire immediately?</span></sup> After <a id="idx:schedulefire3:104"></a><span class="pred-ext">schedule_fire/3</span> 
we do <a id="idx:setupltwaitfired6:105"></a><span class="pred-ext">setup_lt_wait_fired/6</span>. 
If <code>THolds &lt; TMin + G</code> we call <a id="idx:setupltwaittrue5:106"></a><span class="pred-ext">setup_lt_wait_true/5</span>.

<p><a id="idx:setupltwaitfired6:107"></a><span class="pred-ext">setup_lt_wait_fired/6</span> 
stores a <a id="idx:waitfired5:108"></a><span class="pred-ext">wait_fired/5</span> 
fact.&nbsp;<sup class="fn">14<span class="fn-text">It is confusing that 
two implementations of this waiting are present in the code, depending 
on the <a id="idx:recwait0:109"></a><span class="pred-ext">recwait/0</span> 
switch.</span></sup></dd>
<dt class="pubdef"><a id="setup_lt_notground_fv/13"><strong>setup_lt_notground_fv</strong>(<var>+TStart, 
+FV, +FVL, +LitData, +ToDoAnte, +AnteHolds, +THolds, +ConseRId, +PV, 
+Delay, +Id, +IdTerm, +Removed</var>)</a></dt>
<dd class="defbody">

<p><var>AnteHolds</var> holds for Time Interval between <var>TStart</var> 
and
<var>THolds</var>. <var>ToDoAnte</var> is the conjunction that needs to 
hold.
<var>LitData</var> is the Literal under investigation. <var>FV</var> are 
the free variables of the Literal and <var>FVL</var> is a list of 
instantiations that have been dealt with elsewhere.

<p><var>Delay</var> is <code>efgh(E,F,G,H)</code>, <var>ConseRId</var> 
is the consequent.

<p><code>Removed</code> indicates the source of the call. In case of
<code>update_activity_time1(wait_var...)</code>, the
<code>wait_var</code> term is Removed and the Removed is propagated 
along.

<p><var>PV</var> is probably the characterization of the variables:<code>pv(Arga, 
Sorta,Kinda,Arg1a)</code>.

<p><em>FV</em>, <em>fv</em> are abreviations of Free Variables (Prolog 
variables).

<p><a id="idx:setupltnotgroundfv13:110"></a><a class="pred" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a> 
is called by <a id="idx:setupltnotground9:111"></a><span class="pred-ext">setup_lt_notground/9</span>, 
it by
<a id="idx:setupltnormed8:112"></a><a class="pred" href="#setup_lt_normed/8">setup_lt_normed/8</a>, 
it by <a id="idx:setuplt6:113"></a><a class="pred" href="#setup_lt/6">setup_lt/6</a>.
<a id="idx:setuplt6:114"></a><a class="pred" href="#setup_lt/6">setup_lt/6</a> 
is called from <a id="idx:setupnontrivialleadsto5:115"></a><span class="pred-ext">setup_nontrivial_leadsto/5</span>.
<a id="idx:setupltnormed8:116"></a><a class="pred" href="#setup_lt_normed/8">setup_lt_normed/8</a> 
is also called by <a id="idx:instantiateop16:117"></a><span class="pred-ext">instantiate_op/16</span> 
(called in <a id="idx:adddefaultcwa17:118"></a><span class="pred-ext">add_default_cwa/17</span>) 
and <a id="idx:failfilterhandleRR16:119"></a><span class="pred-ext">fail_filter_handleRR/16</span>, 
part of <a id="idx:filterdefaultshandleothers14:120"></a><span class="pred-ext">filter_defaults_handle_others/14</span> 
in
<a id="idx:setupltnotgroundfv13:121"></a><a class="pred" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a>.

<p>We probably handle the rule in this call up to HandledTime.

<p>Now, if at the call <code>THolds &lt; HandledTime</code>, we start 
all over for this partially instantiated sequence of literals by calling <a id="idx:getnewtholds15:122"></a><a class="pred" href="#get_new_tholds/15">get_new_tholds/15</a>. 
Apparently the order of literals is reversed here.
<a id="idx:getnewtholds15:123"></a><a class="pred" href="#get_new_tholds/15">get_new_tholds/15</a> 
is called here and by <a id="idx:getnewtholds15:124"></a><a class="pred" href="#get_new_tholds/15">get_new_tholds/15</a> 
itself.

<p>If <code>THolds &gt;= HandledTime</code>
<a id="idx:setupltnotgroundfv13:125"></a><a class="pred" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a> 
analyses the current <code>LitData</code> first for all AtomTraces in <a id="idx:filterdefaultshandleothers4:126"></a><span class="pred-ext">filter_defaults_handle_others/4</span> 
and all cwa matches in <a id="idx:adddefaultcwa17:127"></a><span class="pred-ext">add_default_cwa/17</span>, 
handles those separately by
<a id="idx:checkfireisolated5:128"></a><span class="pred-ext">check_fire_isolated/5</span> 
or <a id="idx:setupltnormed8:129"></a><a class="pred" href="#setup_lt_normed/8">setup_lt_normed/8</a>. 
All those instantiations of <var>FV</var> handled separately are added 
to <var>FVL</var> and we finally call <a id="idx:setupltnotground1default12:130"></a><span class="pred-ext">setup_lt_notground1default/12</span> 
that calls
<a id="idx:setupltwaitvar12:131"></a><a class="pred" href="#setup_lt_wait_var/12">setup_lt_wait_var/12</a> 
with <code>Atom</code>, <code>FV</code>, <code>FVL</code> values 
implying that <code>FV</code> from <code>FVL</code> has been handled, 
but we need to check other instantiations.</dd>
<dt class="pubdef"><a id="get_new_tholds/15"><strong>get_new_tholds</strong>(<var>AnteHoldsTODO, 
AHDone, TStart, THoldsNew1, Tholds,FV, FVL, LitData, ToDoAnte, 
ConseRId,PV,Delay, Id,IdTerm,Removed</var>)</a></dt>
<dd class="defbody">

<p>Called by <a id="idx:setupltnotgroundfv13:132"></a><a class="pred" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a> 
and by <a id="idx:getnewtholds15:133"></a><a class="pred" href="#get_new_tholds/15">get_new_tholds/15</a> 
itself.

<p><var>AnteHoldsTODO</var> is an earlier instantiated sequence of 
literals that needs to be extended in range up to
<var>THandled</var> (or further?). <var>AHDone</var> is the sequence 
that has been checked and hold between
<var>TStart</var> and <var>THoldsNew1</var>.
<var>Tholds</var> is the result.&nbsp;<sup class="fn">15<span class="fn-text">TODO: 
Details of Tholds, is this a return parameter?</span></sup>

<p><sup class="fn">16<span class="fn-text">When analysing the source:Be 
aware that in <a id="idx:getnewtholds15:134"></a><a class="pred" href="#get_new_tholds/15">get_new_tholds/15</a> 
the <code>Atom</code> in <code>[ds_lh(lit(Atom,PN),Id1,IdTerm1)|AnteHoldsTODO]</code> 
is ground, and has nothing to do with <code>FV</code> and <code>FVL</code>.</span></sup>

<p>First, if <code>AnteHoldsTODO ==[]</code>, we continue with <a id="idx:setupltnotgroundfv13:135"></a><a class="pred" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a> 
with the increased time interval. Otherwise we follow <var>AnteHoldsTODO</var> 
Literals.

<p>NEXT: What does <code>find_min_range_ground(Atom, PN, Tholds, O2)</code> 
do? Probably: Inspect Literal starting from Tholds.</dd>
<dt class="pubdef"><a id="setup_lt_wait_var/12"><strong>setup_lt_wait_var</strong>(<var>FV, 
FVL, LitData, ToDoAnte, AnteHolds, TMin, THolds, ConseRId, PV, Delay, 
Id, IdTerm</var>)</a></dt>
<dd class="defbody">

<p>Probably: We know <var>AnteHolds</var> is ok between <var>TMin</var> 
and <var>THolds</var>.
<var>LitData</var> is the current literal that has been analyzed. FV are 
the free variables in the Literal, <code>FVL</code> is the list of 
instantiations of FV that have been dealt with, for which this setup is 
not responsible at all. Called by
<a id="idx:setupltnotground1default12:136"></a><span class="pred-ext">setup_lt_notground1default/12</span> 
( same arguments) which is only called as last call in
<a id="idx:setupltnotgroundfv13:137"></a><a class="pred" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a>.

<p>Although we know <var>AnteHolds</var> is true starting from <var>TMin</var>, 
we also know that no <var>LitData</var> literal not having <var>FVL</var> 
instantiation is true starting from the current handled time.

<p>We need to check that <var>TMin</var> is not relevant! Indeed it is 
not: see <a id="idx:updateactivitytime12:138"></a><span class="pred-ext">update_activity_time1/2</span> 
for the <code>wait_var</code> term.
<var>TMin</var> is only used to characterize the <var>Removed</var> 
argument for identifying the current activity. So, ... TODO: later 
remove the unnecessary <var>TMin</var> argument from
<code>wait_var</code> terms.

<p>TODO
<ul class="latex">
<li>Really nail down the meaning of <code>wait_var</code>, also at what 
stage are what values for <var>TMin</var> and <var>THolds</var> set.
<li>Will <code>wait_vars</code> become invalidated? Inspect <a id="idx:getnewtholds15:139"></a><a class="pred" href="#get_new_tholds/15">get_new_tholds/15</a>.
<li>For a <code>wait_var</code> entry, can a result be found that 
extends <var>AnteHolds</var> starting at <var>TMin</var>? Probably: it 
could be that some rule has not fired yet, giving a new <var>LitData</var> 
instantiation. But please create an example.
</ul>
</dd>
</dl>

<p>

<h2><a id="sec:5"><span class="sec-nr">5</span> <span class="sec-title">wait 
entries</span></a></h2>

<p><code>wait</code> entries use an additional time <code>T</code> that 
determines whether the entry should be handled in the current step:

<pre class="code">
update_activity_times1(ResultTime) :-
    (    get_wait1(T, Activity, Ref),
         cmp_lt(T, ResultTime),
         retract_wait1(Ref),
         update_activity_time(Activity, T),
         fail
    ;    true
    ).
</pre>

<p><sup class="fn">17<span class="fn-text">ResultTime is the 
current/new, just updated HandledTime.</span></sup>

<p>Times involved in <code>wait</code> entries:

<dl class="latex">
<dt><b>TStart</b></dt>
<dd>
from what time do we need new true LitData
</dd>
<dt><b>TEnd</b></dt>
<dd>
up to what time does <var>AnteHolds</var> hold, for <code>wait_var</code>
</dd>
<dt><b>THandle</b></dt>
<dd>
At or before what HandledTime should <code>wait</code> entry be updated.
</dd>
<dt><b>TFirstResult</b></dt>
<dd>
First time that consequent could become true, see <a id="idx:activityminresulttime2:140"></a><span class="pred-ext">activity_min_result_time/2</span>.
</dd>
</dl>

<p>As we cannot efficiently select those wait facts with <code>T &lt; 
HandledTime</code>, we could inspect all wait entries and calculate 
relevant times each time.

<p>

<h3><a id="sec:5.1"><span class="sec-nr">5.1</span> <span class="sec-title">wait</span></a></h3>

<p><code>TStart</code>: We should or could, start inspecting the wait 
entry as soon as new values are available from that time. Alternatively 
we could wait till
<code>TStart + g</code>. So, <code>THandle</code> could be <code>TStart</code>, 
or <code>TStart + g</code>.

<p>The first time the consequent should become true:
<code>TStart + g + e</code>

<p>At this time, we store
<code>wait_var(Id, IdTerm, HT, TMin, FV, FVL, LitData, ToDoAnte, 
AnteHolds, THolds, ConseRId, PV, Delay)</code>.

<p>As shown elsewhere, <var>TMin</var> is not relevant, HT is the time 
up to which we looked at LitData, FVL, and up to where there is no value 
available and from where the value is unknown/blank.

<p>

<h2><a id="sec:6"><span class="sec-nr">6</span> <span class="sec-title">So 
far</span></a></h2>

<p>Try documenting the whole data structure that describes the state of 
each leadsto rule first. All invariants, the understanding of having 
every possible outcome of a leadsto rule represented.

<p>At what stage the HandledTime invariant is. Understanding the 
get_new_tholds, the reverse is on purpose as that is part of the 
invariant, having a partial instantiation left to right.

<p>After that, try understanding the cleanup efforts of <code>wait_var</code>.

<p><h2 id="sec:ltsyntax"><a id="sec:7"><span class="sec-nr">7</span> <span class="sec-title">"Syntax" 
of Leadsto Specifications</span></a></h2>

&nbsp;<a id="sec:ltsyntax"></a>

<p>Copied from syntax.txt:

<pre class="code">
The leadsto input syntax is prolog syntax, but with the
following added/changed operator definitions.
(For input of leadsto specs in prolog, the : redefinition is 
 awkward. I do a push/pop operator call for reading)

                        op(150, xfx, :),
                        op(700, xfy, &lt;),
                        op(700, xfy, &lt;=),
                        op(700, xfy, =&lt;),
                        op(700, xfy, &gt;),
                        op(700, xfy, &gt;=)
                        ]).

Currently, only the top level terms are described. I am working
on syntax (+minimal explanation of semantics) of the top level
terms, but especially the sub terms.

sub terms:

% VAR:PLPCE:
    VAR, in principle, a prolog term, although Uppercase atoms 
    are allowed. Quotes around atoms are allowed.
     TODO: are unquoted uppercase functors allowed?
     e.g. P(a) TODO: what are further restrictions and 
     interpretations of PLPCE terms TODO: junk this stupid 
     name "PLPCE".

% start_time(PLPCE)
% end_time(PLPCE)
% global_lambda(PLPCE)


TODO: why those qterms?
% qterm(cwa(X))        cwa_node 
% qterm(external(X))   external_node
% qterm(X) ...         other_node

% display(_,_)
% display_number_range(_,_,_,_)

% periodic(Vars, Range, Period:PLPCE, Formula) is_list(Vars)
                 * handle_interval(Vars, Range, Formula, Root, Son, Extra)
% periodic(ST, ET, Period:PLPCE, Formula)
                 * handle_interval([], range(ST, ET), Formula, Root,Son,Extra),
% periodic(Vars, ST, ET, Period:PLPCE, Formula)
                 * handle_interval(Vars, range(ST, ET),Formula,Root,Son,Extra)
% interval(Vars, ST, ET, Formula)
                 * handle_interval(Vars, Range, Formula, Root, _Son, Extra)
% interval(Vars, ST, ET, Formula)
                 * handle_interval(Vars, range(ST, ET),Formula,Root,_Son,Extra)
% interval(ST, ET, Formula)
                 * handle_interval([], range(ST, ET), Formula,Root,_Son,Extra)

% leadsto(AnteFormula, ConseFormula, Delay)
        * handle_leadsto1(Root, AnteFormula, ConseFormula, Delay, Extra, _Son)
% leadsto(Vars, AnteFormula, ConseFormula, Delay)
        * handle_leadsto1(Root, AnteFormula, ConseFormula, Delay, Extra, Son)
% specification(_) 
                   * IGNORED
% content(C)
                * TODO? assertz(dyn_content(C))
% denotes(Header, Formula)
                  * term_to_formula_node(Formula, FormulaNode, Extra),
                new(PN, property_def_node(@off)),
                send(PN, fill_header, Header),
                send(PN, son, FormulaNode),
                send(Root, son, PN)
% (sort_element(SortName:PLPCE, Term):- member(Term2, List) with Term==Term2
                * test_sort_def(SortName, List, Extra),
        ensure_sort_son(Root, SortName1, SNode),
        add_sort_contents(SNode, List).
% constant(Name, Value)
  * check_constant(Name, Value),
        send(Root, son, new(N, constant_def_node)),
        send(N, fill_header, Name),
        send(N, fill_value, Value)
% sortdef(SortName:PLPCE, Objs)
  * test_sort_def(SortName, Objs, Extra),
        send(Root, son, new(SN, sort_node)),
        send(SN, change_gui_prop, sort_name, SortName1),
        add_sort_contents(SN, Objs).
% cwa(PLPCE)
% model(PLPCE)
% [specification_element] 
  * generic node
</pre>

<p>

<h2><a id="sec:8"><span class="sec-nr">8</span> <span class="sec-title">TODO</span></a></h2>

<p>

<h3><a id="sec:8.1"><span class="sec-nr">8.1</span> <span class="sec-title">waitvar, 
waitfired</span></a></h3>

<p><a id="idx:getwait13:141"></a><span class="pred-ext">get_wait1/3</span> 
is often called with all variables leading to calls of <a id="idx:currentkey1:142"></a><span class="pred-ext">current_key/1</span> 
and looping over all wait_var entries for each
<a id="idx:firstpossibleactivityresult1:143"></a><span class="pred-ext">first_possible_activity_result/1</span> 
call.

<p>

<h4><a id="sec:8.1.1"><span class="sec-nr">8.1.1</span> <span class="sec-title">Debugging, 
verifying waitvar FV,FVL aspects</span></a></h4>

<p>I changed check_isolated_fire_rest. We need to test it for cases 
where there are variables. Make sure that <a id="idx:checkisolatedfirerest8:144"></a><span class="pred-ext">check_isolated_fire_rest/8</span> 
is fired in some example, sometimes with excluded FV,FVL, sometimes not.

<p>Follow <code>FV</code>, <code>FVL</code> with <code>FV ==[]</code>

<p>Can a <code>wait_var</code> or <code>wait_fired</code> fire in case 
of <code>FVL=[[]]</code>?

<p>do_default_cwa_isolated_no_trace:
<code>\+ find_atom_trace</code>: we need to have the neg value in the 
range! Probably first generate an example where we have an atom trace 
but cwa holds in some range and a rule should fire there.

<p>Is it an option to produce a simpler less efficient algorithm that we 
can use to validate the result?

<p>

<h3><a id="sec:8.2"><span class="sec-nr">8.2</span> <span class="sec-title">Solving 
bugje-nondeterminism</span></a></h3>

<p><a id="idx:checkisolatedfirerest9:145"></a><span class="pred-ext">check_isolated_fire_rest/9</span> 
added FV, FVL so that we do not fire FV out of FVL.

<p>To trust this more, I would like to understand the gc aspects. Let us 
follow <code>wait_fired</code>

<p>

<h3><a id="sec:8.3"><span class="sec-nr">8.3</span> <span class="sec-title">analyse 
case</span></a></h3>

<p>We have a leadsto rule

<pre class="code">
if a and b  then(e=0,f=1,g=1,h=1) c
interval(a, 0, 1)
interval(b, 0, 1)
</pre>

<p>After we have fired the rule once, we have <code>wait_var</code> 
entries for <code>a</code> and <code>b</code>. At a later stage we 
should remove those entries as they have <code>FV ==[]</code> and <code>FVL 
== [[]]</code> so they should never lead to new results. But the 
programming was sloppy. A number of aspects: the <code>wait_var</code> 
should respect the <code>FVL</code> restriction. It seems to do that but 
not when we replace the entry by an updated one in <a id="idx:getnewtholds15:146"></a><a class="pred" href="#get_new_tholds/15">get_new_tholds/15</a>. 
The problem could also be that we do not make the <code>wait_var</code> 
start from a new place.

<p>Let us follow the second step where we have updated <code>HandledTime</code> 
to the start of the <code>c</code> derived interval. We encounter
<code>wait_var(ds_lh(b),..)</code>. get <code>O2 = fail(1,_)</code>

<p>In <a id="idx:setupltnotgroundfv13:147"></a><a class="pred" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a> 
I see: <code>assert_debug(cmp_ge(THolds, HT))</code>. That should be the 
case for all <code>setup_lt_wait_var</code>, <a id="idx:setwaitvar14:148"></a><span class="pred-ext">set_wait_var/14</span> 
calls, so check <a id="idx:rmgcwaitvars18:149"></a><span class="pred-ext">rm_gc_wait_vars1/8</span>.

<p>Still, I would prefer formulating the semantics of <code>wait_var</code> 
over this skimming and avoiding.

<p>Where do we set <code>wait_var</code>? We have recorded <code>dyn_wait(HT, 
Activity)</code> and
<code>dyn_wait_var(Id1, IdTerm, HT, TMin, FV, FVL, LitData, ToDoAnte, 
AnteHolds, THolds, ConseRId,PV, Delay, HTN))</code>.
<code>wait_var</code> is set by <a id="idx:setwait1var14:150"></a><span class="pred-ext">set_wait1_var/14</span> 
and removed by <a id="idx:retractwait12:151"></a><span class="pred-ext">retract_wait1/2</span> 
or <a id="idx:retractwait11:152"></a><span class="pred-ext">retract_wait1/1</span> 
(<a id="idx:erase1:153"></a><span class="pred-ext">erase/1</span>).
<a id="idx:setwait1var14:154"></a><span class="pred-ext">set_wait1_var/14</span> 
only called by <a id="idx:setwaitvar14:155"></a><span class="pred-ext">set_wait_var/14</span>.
<a id="idx:setwaitvar14:156"></a><span class="pred-ext">set_wait_var/14</span> 
called by <a id="idx:setupltwaitvar12:157"></a><a class="pred" href="#setup_lt_wait_var/12">setup_lt_wait_var/12</a> 
which adds HandledTime as an argument. <a id="idx:setwaitvar14:158"></a><span class="pred-ext">set_wait_var/14</span> 
also called by <a id="idx:rmgcwaitvar18:159"></a><span class="pred-ext">rm_gc_wait_var1/8</span>.

<p>Let us check wait_fired too. It calls <a id="idx:rmgcwaitwaitvars8:160"></a><span class="pred-ext">rm_gc_wait_wait_vars/8</span>. 
This seems to be ok as the instantiated antecedent has no uninstantiated 
variables left.

<p>TODO: Do we assure that all <code>wait</code> records are removed 
before a next run?

<p>Some doubt about at what time to hang <code>wait</code> entries. Do 
we add <code>e</code> to the value because the result can only come 
after a delay or do we need to fire rules as soon as possible, i.e. when 
a new non-blank value can be available? In that case, we could also add <code>g</code>, 
as a rule could only results at <code>e + g</code> after the current 
HandledTime?

<p>The question is: how do we define HandledTime?
<ol class="latex">
<li>All values up to HandledTime have been derived?
<li>Or all values up to HandledTime have been derived and all results of 
applying rules on intervals up to HandledTime are in?
</ol>

<p>I will need to rethink this, I probably chose the first option. But 
the second one seems to be possible too. Let me put some time into 
checking the second case although it seems hard to determine the next 
HandledTime.

<p>Possibly there could be more options even. The <code>wait</code> 
entries should not be linked to a new HandledTime value?

<p>The <code>wait</code> entries should be defined independent from <code>HandledTime</code>, 
as they are now.

<p><code>wait_var</code> is linked to one <code>LitData</code> entry. Of <code>FV</code> 
and
<code>FVL</code> we know that no value is known before TStart. We know 
that AnteHolds holds up to THolds. No other time should be needed. 
CLEAR! NO DOUBT.

<p>We need to check this. Especially look at updating <code>wait</code> 
entries.

<p>We store <code>wait</code> entries that depend on changes in the 
future. We can also calculate from what time a result could be expected. 
So after a "step" that checks whether rules may fire given <code>wait</code> 
entries and then updating <code>wait</code> entries, we determine <code>HandledTime</code>, 
the earliest time any of the <code>wait</code> entries could produce a 
result. Then the next step follows.

<p>Issues:
<ul class="latex">
<li>The actual firing? When analysing a <code>wait</code> entry, a rule 
could fire. Should we fire immediately? Should we wait? Does it matter? 
It seems that the sooner we decide to fire a rule, the more we know and 
the further we could extend "true" intervals. The firing could well 
change values before the new HandledTime, or could it? Probably not! It 
is the definition of the new HandledTime: no <code>wait</code> entry can 
produce results before the new HandledTime. Why do we gather <a id="idx:dynschedulefire3:161"></a><span class="pred-ext">dyn_schedule_fire/3</span> 
facts and fire them in one batch using <a id="idx:handlefired0:162"></a><span class="pred-ext">handle_fired/0</span> 
? In the current implementation <a id="idx:handlefired0:163"></a><span class="pred-ext">handle_fired/0</span> 
is called at the beginnning of <a id="idx:handledtimestep1:164"></a><span class="pred-ext">handled_time_step/1</span> 
and once at the end, after the last
<a id="idx:handledtimestep1:165"></a><span class="pred-ext">handled_time_step/1</span>. 
If <a id="idx:updateactivitytimes1:166"></a><span class="pred-ext">update_activity_times/1</span> 
only schedules rules to fire, then before doing the next <a id="idx:updateactivitytimes1:167"></a><span class="pred-ext">update_activity_times/1</span>, 
all scheduled firings belonging to the previous <a id="idx:uat1:168"></a><span class="pred-ext">uat/1</span> 
should have fired. But still, why not fire immediately? It could be that 
we somehow depend on a known state of the future over one <code>wait</code> 
batch? Let us postpone this.
</ul>

<h1><a id="document-index">Index</a></h1>

<dl>
<dt class="index-sep">?</dt>
<dt>activity_min_result_time/2</dt>
<dd>
<a class="idx" href="#idx:activityminresulttime2:140">5</a></dd>
<dt>add_default_cwa/17</dt>
<dd>
<a class="idx" href="#idx:adddefaultcwa17:118">4.6</a> <a class="idx" href="#idx:adddefaultcwa17:127">4.6</a></dd>
<dt><a class="idx" href="#atom_key/2">atom_key/2</a></dt>
<dt><a class="idx" href="#atom_trace/3">atom_trace/3</a></dt>
<dd>
<a class="idx" href="#idx:atomtrace3:14">2.2.1</a> <a class="idx" href="#idx:atomtrace3:17">2.2.1</a></dd>
<dt>check_fire_isolated/5</dt>
<dd>
<a class="idx" href="#idx:checkfireisolated5:128">4.6</a></dd>
<dt>check_isolated_fire_rest/8</dt>
<dd>
<a class="idx" href="#idx:checkisolatedfirerest8:144">8.1.1</a></dd>
<dt>check_isolated_fire_rest/9</dt>
<dd>
<a class="idx" href="#idx:checkisolatedfirerest9:145">8.2</a></dd>
<dt>code_atom/4</dt>
<dd>
<a class="idx" href="#idx:codeatom4:84">3.4</a></dd>
<dt><a class="idx" href="#code_conse/6">code_conse/6</a></dt>
<dt><a class="idx" href="#code_form/4">code_form/4</a></dt>
<dd>
<a class="idx" href="#idx:codeform4:72">3.4</a> <a class="idx" href="#idx:codeform4:77">3.4</a> <a class="idx" href="#idx:codeform4:78">3.4</a> <a class="idx" href="#idx:codeform4:82">3.4</a> <a class="idx" href="#idx:codeform4:85">3.4</a></dd>
<dt>current_key/1</dt>
<dd>
<a class="idx" href="#idx:currentkey1:142">8.1</a></dd>
<dt>discontinous/1</dt>
<dd>
<a class="idx" href="#idx:discontinous1:20">2.2.3</a></dd>
<dt>do_setup_time/2</dt>
<dd>
<a class="idx" href="#idx:dosetuptime2:45">2.2.3</a></dd>
<dt>do_setup_times/2</dt>
<dd>
<a class="idx" href="#idx:dosetuptimes2:7">2.1</a></dd>
<dt><a class="idx" href="#dyn_atom_trace/3">dyn_atom_trace/3</a></dt>
<dd>
<a class="idx" href="#idx:dynatomtrace3:11">2.2.1</a> <a class="idx" href="#idx:dynatomtrace3:15">2.2.1</a> <a class="idx" href="#idx:dynatomtrace3:18">2.2.1</a> <a class="idx" href="#idx:dynatomtrace3:56">2.2.3</a></dd>
<dt><a class="idx" href="#dyn_atom_trace_backup/3">dyn_atom_trace_backup/3</a></dt>
<dd>
<a class="idx" href="#idx:dynatomtracebackup3:10">2.2.1</a> <a class="idx" href="#idx:dynatomtracebackup3:12">2.2.1</a> <a class="idx" href="#idx:dynatomtracebackup3:16">2.2.1</a> <a class="idx" href="#idx:dynatomtracebackup3:19">2.2.1</a></dd>
<dt><a class="idx" href="#dyn_currently_loaded/2">dyn_currently_loaded/2</a></dt>
<dt>dyn_handled_wait_var_instance/4</dt>
<dd>
<a class="idx" href="#idx:dynhandledwaitvarinstance4:86">4.5</a> <a class="idx" href="#idx:dynhandledwaitvarinstance4:93">4.5</a></dd>
<dt>dyn_interval/1</dt>
<dd>
<a class="idx" href="#idx:dyninterval1:54">2.2.3</a></dd>
<dt>dyn_leadsto/5</dt>
<dd>
<a class="idx" href="#idx:dynleadsto5:50">2.2.3</a></dd>
<dt>dyn_rm_gc_wait_vars/8</dt>
<dd>
<a class="idx" href="#idx:dynrmgcwaitvars8:94">4.5</a></dd>
<dt>dyn_schedule_fire/3</dt>
<dd>
<a class="idx" href="#idx:dynschedulefire3:161">8.3</a></dd>
<dt><a class="idx" href="#dyn_sim_status/2">dyn_sim_status/2</a></dt>
<dt>dyn_sortdef/5</dt>
<dd>
<a class="idx" href="#idx:dynsortdef5:28">2.2.3</a></dd>
<dt>end_time/1</dt>
<dd>
<a class="idx" href="#idx:endtime1:6">2.1</a></dd>
<dt>erase/1</dt>
<dd>
<a class="idx" href="#idx:erase1:153">8.3</a></dd>
<dt>fail_filter_handle/15</dt>
<dd>
<a class="idx" href="#idx:failfilterhandle15:90">4.5</a></dd>
<dt><a class="idx" href="#filled_atom_trace/3">filled_atom_trace/3</a></dt>
<dd>
<a class="idx" href="#idx:filledatomtrace3:13">2.2.1</a></dd>
<dt>filter_defaults_handle_others/14</dt>
<dd>
<a class="idx" href="#idx:filterdefaultshandleothers14:120">4.6</a></dd>
<dt>filter_defaults_handle_others/4</dt>
<dd>
<a class="idx" href="#idx:filterdefaultshandleothers4:126">4.6</a></dd>
<dt><a class="idx" href="#find_atom_trace/2">find_atom_trace/2</a></dt>
<dt>first_possible_activity_result/1</dt>
<dd>
<a class="idx" href="#idx:firstpossibleactivityresult1:143">8.1</a></dd>
<dt>forall/2</dt>
<dd>
<a class="idx" href="#idx:forall2:65">2.2.3</a></dd>
<dt>get_model_checking_p_rules/0</dt>
<dd>
<a class="idx" href="#idx:getmodelcheckingprules0:51">2.2.3</a></dd>
<dt><a class="idx" href="#get_new_tholds/15">get_new_tholds/15</a></dt>
<dd>
<a class="idx" href="#idx:getnewtholds15:122">4.6</a> <a class="idx" href="#idx:getnewtholds15:123">4.6</a> <a class="idx" href="#idx:getnewtholds15:124">4.6</a> <a class="idx" href="#idx:getnewtholds15:133">4.6</a> <a class="idx" href="#idx:getnewtholds15:134">4.6</a> <a class="idx" href="#idx:getnewtholds15:139">4.6</a> <a class="idx" href="#idx:getnewtholds15:146">8.3</a></dd>
<dt>get_wait1/3</dt>
<dd>
<a class="idx" href="#idx:getwait13:141">8.1</a></dd>
<dt>handle_fired/0</dt>
<dd>
<a class="idx" href="#idx:handlefired0:162">8.3</a> <a class="idx" href="#idx:handlefired0:163">8.3</a></dd>
<dt>handle_term/1</dt>
<dd>
<a class="idx" href="#idx:handleterm1:21">2.2.3</a> <a class="idx" href="#idx:handleterm1:24">2.2.3</a></dd>
<dt>handled_time_step/1</dt>
<dd>
<a class="idx" href="#idx:handledtimestep1:8">2.1</a> <a class="idx" href="#idx:handledtimestep1:164">8.3</a> <a class="idx" href="#idx:handledtimestep1:165">8.3</a></dd>
<dt><a class="idx" href="#init_interval_callbacks/10">init_interval_callbacks/10</a></dt>
<dd>
<a class="idx" href="#idx:initintervalcallbacks10:55">2.2.3</a> <a class="idx" href="#idx:initintervalcallbacks10:58">2.2.3</a></dd>
<dt>init_interval_callbacks/9</dt>
<dd>
<a class="idx" href="#idx:initintervalcallbacks9:69">3.4</a></dd>
<dt><a class="idx" href="#initialise_interval/3">initialise_interval/3</a></dt>
<dd>
<a class="idx" href="#idx:initialiseinterval3:22">2.2.3</a> <a class="idx" href="#idx:initialiseinterval3:33">2.2.3</a></dd>
<dt><a class="idx" href="#initialise_interval_periodic/4">initialise_interval_periodic/4</a></dt>
<dd>
<a class="idx" href="#idx:initialiseintervalperiodic4:23">2.2.3</a> <a class="idx" href="#idx:initialiseintervalperiodic4:34">2.2.3</a></dd>
<dt>instantiate_op/16</dt>
<dd>
<a class="idx" href="#idx:instantiateop16:91">4.5</a> <a class="idx" href="#idx:instantiateop16:117">4.6</a></dd>
<dt><a class="idx" href="#load_simulation/1">load_simulation/1</a></dt>
<dd>
<a class="idx" href="#idx:loadsimulation1:29">2.2.3</a> <a class="idx" href="#idx:loadsimulation1:35">2.2.3</a></dd>
<dt>mark_handled/7</dt>
<dd>
<a class="idx" href="#idx:markhandled7:87">4.5</a> <a class="idx" href="#idx:markhandled7:88">4.5</a></dd>
<dt>model/1</dt>
<dd>
<a class="idx" href="#idx:model1:42">2.2.3</a></dd>
<dt>postponed_rm_gc/0</dt>
<dd>
<a class="idx" href="#idx:postponedrmgc0:96">4.5</a> <a class="idx" href="#idx:postponedrmgc0:98">4.5</a></dd>
<dt>recwait/0</dt>
<dd>
<a class="idx" href="#idx:recwait0:66">3.3</a> <a class="idx" href="#idx:recwait0:109">4.6</a></dd>
<dt><a class="idx" href="#reset_sim_info/0">reset_sim_info/0</a></dt>
<dt>retract_wait1/1</dt>
<dd>
<a class="idx" href="#idx:retractwait11:152">8.3</a></dd>
<dt>retract_wait1/2</dt>
<dd>
<a class="idx" href="#idx:retractwait12:151">8.3</a></dd>
<dt>rm_gc_wait_var1/8</dt>
<dd>
<a class="idx" href="#idx:rmgcwaitvar18:159">8.3</a></dd>
<dt>rm_gc_wait_vars/8</dt>
<dd>
<a class="idx" href="#idx:rmgcwaitvars8:95">4.5</a></dd>
<dt>rm_gc_wait_vars1/8</dt>
<dd>
<a class="idx" href="#idx:rmgcwaitvars18:89">4.5</a> <a class="idx" href="#idx:rmgcwaitvars18:97">4.5</a> <a class="idx" href="#idx:rmgcwaitvars18:149">8.3</a></dd>
<dt>rm_gc_wait_wait_vars/8</dt>
<dd>
<a class="idx" href="#idx:rmgcwaitwaitvars8:160">8.3</a></dd>
<dt>run_simulation/2</dt>
<dd>
<a class="idx" href="#idx:runsimulation2:1">1.2</a></dd>
<dt>runmodel/4</dt>
<dd>
<a class="idx" href="#idx:runmodel4:39">2.2.3</a> <a class="idx" href="#idx:runmodel4:41">2.2.3</a></dd>
<dt><a class="idx" href="#runshowspec/1">runshowspec/1</a></dt>
<dt>runspec/1</dt>
<dd>
<a class="idx" href="#idx:runspec1:38">2.2.3</a> <a class="idx" href="#idx:runspec1:46">2.2.3</a></dd>
<dt><a class="idx" href="#runspec1/0">runspec1/0</a></dt>
<dd>
<a class="idx" href="#idx:runspec10:2">1.2</a> <a class="idx" href="#idx:runspec10:26">2.2.3</a> <a class="idx" href="#idx:runspec10:32">2.2.3</a> <a class="idx" href="#idx:runspec10:40">2.2.3</a> <a class="idx" href="#idx:runspec10:43">2.2.3</a> <a class="idx" href="#idx:runspec10:57">2.2.3</a></dd>
<dt>runspec_rest/0</dt>
<dd>
<a class="idx" href="#idx:runspecrest0:3">1.2</a> <a class="idx" href="#idx:runspecrest0:9">2.1</a> <a class="idx" href="#idx:runspecrest0:53">2.2.3</a> <a class="idx" href="#idx:runspecrest0:103">4.6</a></dd>
<dt><a class="idx" href="#runspecdo/1">runspecdo/1</a></dt>
<dd>
<a class="idx" href="#idx:runspecdo1:36">2.2.3</a></dd>
<dt><a class="idx" href="#savemodelspec_cleanup/2">savemodelspec_cleanup/2</a></dt>
<dt>savetrace/1</dt>
<dd>
<a class="idx" href="#idx:savetrace1:44">2.2.3</a></dd>
<dt><a class="idx" href="#savetrace1/1">savetrace1/1</a></dt>
<dt><a class="idx" href="#savetracesetup/3">savetracesetup/3</a></dt>
<dt>schedule_fire/3</dt>
<dd>
<a class="idx" href="#idx:schedulefire3:102">4.6</a> <a class="idx" href="#idx:schedulefire3:104">4.6</a></dd>
<dt>set_wait1_var/14</dt>
<dd>
<a class="idx" href="#idx:setwait1var14:150">8.3</a> <a class="idx" href="#idx:setwait1var14:154">8.3</a></dd>
<dt>set_wait_var/14</dt>
<dd>
<a class="idx" href="#idx:setwaitvar14:148">8.3</a> <a class="idx" href="#idx:setwaitvar14:155">8.3</a> <a class="idx" href="#idx:setwaitvar14:156">8.3</a> <a class="idx" href="#idx:setwaitvar14:158">8.3</a></dd>
<dt>setup_atom_state_boundaries/0</dt>
<dd>
<a class="idx" href="#idx:setupatomstateboundaries0:52">2.2.3</a></dd>
<dt><a class="idx" href="#setup_leadsto/6">setup_leadsto/6</a></dt>
<dd>
<a class="idx" href="#idx:setupleadsto6:25">2.2.3</a> <a class="idx" href="#idx:setupleadsto6:49">2.2.3</a> <a class="idx" href="#idx:setupleadsto6:68">3.4</a></dd>
<dt><a class="idx" href="#setup_lt/6">setup_lt/6</a></dt>
<dd>
<a class="idx" href="#idx:setuplt6:63">2.2.3</a> <a class="idx" href="#idx:setuplt6:70">3.4</a> <a class="idx" href="#idx:setuplt6:71">3.4</a> <a class="idx" href="#idx:setuplt6:73">3.4</a> <a class="idx" href="#idx:setuplt6:113">4.6</a> <a class="idx" href="#idx:setuplt6:114">4.6</a></dd>
<dt><a class="idx" href="#setup_lt_conse/6">setup_lt_conse/6</a></dt>
<dt>setup_lt_internal/6</dt>
<dd>
<a class="idx" href="#idx:setupltinternal6:60">2.2.3</a></dd>
<dt><a class="idx" href="#setup_lt_normed/8">setup_lt_normed/8</a></dt>
<dd>
<a class="idx" href="#idx:setupltnormed8:64">2.2.3</a> <a class="idx" href="#idx:setupltnormed8:74">3.4</a> <a class="idx" href="#idx:setupltnormed8:75">3.4</a> <a class="idx" href="#idx:setupltnormed8:92">4.5</a> <a class="idx" href="#idx:setupltnormed8:112">4.6</a> <a class="idx" href="#idx:setupltnormed8:116">4.6</a> <a class="idx" href="#idx:setupltnormed8:129">4.6</a></dd>
<dt>setup_lt_notground/9</dt>
<dd>
<a class="idx" href="#idx:setupltnotground9:100">4.6</a> <a class="idx" href="#idx:setupltnotground9:111">4.6</a></dd>
<dt>setup_lt_notground1default/12</dt>
<dd>
<a class="idx" href="#idx:setupltnotground1default12:130">4.6</a> <a class="idx" href="#idx:setupltnotground1default12:136">4.6</a></dd>
<dt><a class="idx" href="#setup_lt_notground_fv/13">setup_lt_notground_fv/13</a></dt>
<dd>
<a class="idx" href="#idx:setupltnotgroundfv13:101">4.6</a> <a class="idx" href="#idx:setupltnotgroundfv13:110">4.6</a> <a class="idx" href="#idx:setupltnotgroundfv13:121">4.6</a> <a class="idx" href="#idx:setupltnotgroundfv13:125">4.6</a> <a class="idx" href="#idx:setupltnotgroundfv13:132">4.6</a> <a class="idx" href="#idx:setupltnotgroundfv13:135">4.6</a> <a class="idx" href="#idx:setupltnotgroundfv13:137">4.6</a> <a class="idx" href="#idx:setupltnotgroundfv13:147">8.3</a></dd>
<dt>setup_lt_wait_fired/6</dt>
<dd>
<a class="idx" href="#idx:setupltwaitfired6:105">4.6</a> <a class="idx" href="#idx:setupltwaitfired6:107">4.6</a></dd>
<dt>setup_lt_wait_true/5</dt>
<dd>
<a class="idx" href="#idx:setupltwaittrue5:106">4.6</a></dd>
<dt><a class="idx" href="#setup_lt_wait_var/12">setup_lt_wait_var/12</a></dt>
<dd>
<a class="idx" href="#idx:setupltwaitvar12:76">3.4</a> <a class="idx" href="#idx:setupltwaitvar12:131">4.6</a> <a class="idx" href="#idx:setupltwaitvar12:157">8.3</a></dd>
<dt>setup_nontrivial_leadsto/5</dt>
<dd>
<a class="idx" href="#idx:setupnontrivialleadsto5:62">2.2.3</a> <a class="idx" href="#idx:setupnontrivialleadsto5:115">4.6</a></dd>
<dt><a class="idx" href="#setup_rt_intervals/0">setup_rt_intervals/0</a></dt>
<dd>
<a class="idx" href="#idx:setuprtintervals0:30">2.2.3</a> <a class="idx" href="#idx:setuprtintervals0:31">2.2.3</a> <a class="idx" href="#idx:setuprtintervals0:47">2.2.3</a></dd>
<dt>setup_unknown_or_cwa/2</dt>
<dd>
<a class="idx" href="#idx:setupunknownorcwa2:4">2.1</a> <a class="idx" href="#idx:setupunknownorcwa2:48">2.2.3</a></dd>
<dt>show_results/2</dt>
<dd>
<a class="idx" href="#idx:showresults2:37">2.2.3</a></dd>
<dt>simplify_term/4</dt>
<dd>
<a class="idx" href="#idx:simplifyterm4:61">2.2.3</a></dd>
<dt>start_time/1</dt>
<dd>
<a class="idx" href="#idx:starttime1:5">2.1</a></dd>
<dt><a class="idx" href="#tr_arg_prolog1/6">tr_arg_prolog1/6</a></dt>
<dd>
<a class="idx" href="#idx:trargprolog16:79">3.4</a> <a class="idx" href="#idx:trargprolog16:83">3.4</a></dd>
<dt>uat/1</dt>
<dd>
<a class="idx" href="#idx:uat1:168">8.3</a></dd>
<dt>update_activity_time1/2</dt>
<dd>
<a class="idx" href="#idx:updateactivitytime12:138">4.6</a></dd>
<dt>update_activity_times/1</dt>
<dd>
<a class="idx" href="#idx:updateactivitytimes1:99">4.5</a> <a class="idx" href="#idx:updateactivitytimes1:166">8.3</a> <a class="idx" href="#idx:updateactivitytimes1:167">8.3</a></dd>
<dt>update_activity_times1/1</dt>
<dd>
<a class="idx" href="#idx:updateactivitytimes11:67">3.3</a></dd>
<dt>update_sorts/0</dt>
<dd>
<a class="idx" href="#idx:updatesorts0:27">2.2.3</a></dd>
<dt>var_pl_from_var_list/5</dt>
<dd>
<a class="idx" href="#idx:varplfromvarlist5:81">3.4</a></dd>
<dt>var_pl_to_var_list/6</dt>
<dd>
<a class="idx" href="#idx:varpltovarlist6:80">3.4</a></dd>
<dt>wait_fired/5</dt>
<dd>
<a class="idx" href="#idx:waitfired5:108">4.6</a></dd>
<dt>setup_lt_internalL/5</dt>
<dd>
<a class="idx" href="#idx:setupltinternalL5:59">2.2.3</a></dd>
<dt class="index-sep">R</dt>
<dt>fail_filter_handleRR/16</dt>
<dd>
<a class="idx" href="#idx:failfilterhandleRR16:119">4.6</a></dd>
</dl>

</body></html>