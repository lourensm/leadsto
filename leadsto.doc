\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\usepackage{plpage}
\sloppy
\makeindex

\onefile
\htmloutput{.}					% Output directory
\htmlmainfile{pldoc}				% Main document file
\bodycolor{white}				% Page colour

\begin{document}

\title{LeadsTo Software}
\author{Lourens van der Meij \\
	E-mail: \email{lourenstcc@gmail.com}}

\maketitle

\begin{abstract}
This document describes the LeadsTo software.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{LeadsTo core design and implementation}

\subsection{Introduction}

A leadsto specification is encoded as a pl file containing predicates. We should
have an exhaustive documentation of all allowed predicates.

Here we describe the main leadsto procedure algo:run_simulation/2.
This leadsto specification is loaded into the leadsto runtime:

\begin{enumerate}

\item
  The predicates are loaded into module called "spec".

\item
  After that, all terms in the input file are preprocessed, often
  leading to asserted dynamic predicates in the current(algo) module.

  There seems to be almost no compilation at this stage and it looks
  like terms in thee spec module often are asserted as facts into algo
  without any transformation.

  Some translation of sortdefs is performed. If a sort contains less
  than 100 ground terms, it is instantiated, otherwise the sort
  definition is left as is. This leads to spec:sortdef(Sort, Terms). The
  source contains a beginning of a new way of encoding sort definitions.

\item

  If the specification contained a model specification, we run each
  model instance after setting up model parameters.
  Otherwise we perform a single run.

\item
Running the specification

\begin{enumerate}
\item
setup of the runtime (first part of runspec1/0)
\item
performing the firing of rules (runspec_rest/0)
\end{enumerate}

\item
Saving the generated trace
\end{enumerate}

\subsection{LeadsTo specifications}

\subsubsection{Sources for information}

The file \url{userman.html} contains the documentation for most allowed
constructs in LeadsTo specifications. Apart from that we will use the
source to check whether there are more features.

There are some problems with the way leadsto constructs are specified.
They are translated into Prolog facts yet we do not put quotes around upper case
atoms.

\begin{code}
model(m1(Delay:between(10, 12))).
interval([], range(0, 1), a).
leadsto([], a, b, efgh(Delay, Delay, 1, 1)).
\end{code}

Here Delay should be quoted. The leadsto terms allowed seem to be relatively
exaustive. Probabilistic constructs are missing though.

\section{Details}

\subsubsection{Times}

\begin{description}
\item[setuptime]
\item[handledtime]
\item[starttime]
\item[endtime] If not specified there currently is a default of 200 (see end_time/1)
\end{description}

Looking at do_setup_time(TStart, TSetup) it looks like TSetup is identical to TStart, although
it may have been foreseen that options setup_maxg and setup_maxfg could lead to the algorithm
starting before TStartup. start_time is only used when refering to traces, in the algorithm
only setuptime is used.

HandledTime is incremented in handled_time_step/1 and runspec_rest/0 ensures that
at the end of the leadsto algorithm handledtime >= Endtime.
\subsection{Traces}

\subsubsection{Datastructures}

Traces are stored as Prolog facts, each fact represents values of a single ground atom.

Values of an atom over time are represented as a list:
 [range(23.0, 24.0, true), range(17, 18, true)].

The ranges are ordered, the latest time range first. During the execution of our
leadsto algorithm, only necessary values are stored, unknown ranges or false ranges
while cwa(Atom) holds are not part of the trace.

In saved traces all values are represented. Saved traces will only contain
atom values in the range start_time to end_time. The leadsto algorithm may derive values
outside of that range.

TODO: We should discuss alternatives:
\begin{enumerate}
\item
Why not save only necessary values in saved traces?
\item
If saving everything, why not compact the timerange?
[range(T1, T2, TFU1), range(T2, T3, TFU3), ...]
into [T1-TFU1, T2-TFU2, .. TE-[]]

\end{enumerate}


\subsubsection{Variables}

\begin{description}
\predicate{dyn_sim_status}{2}{File, Status}
says in what stage of loading and running the
algo algorithm is. \arg{Status} is \const{loaded}, \const{running} or \const{done}.

\predicate{dyn_currently_loaded}{2}{Kind, File}
says what \arg{File} is loaded and what \arg{Kind}, where \arg{Kind} is \const{trace} or
\arg{sim}.
\end{description}
\subsubsection{Loading and Trace Generation}


\begin{description}
\predicate{load_simulation}{1}{+File}
The specification \arg{File} is loaded into module \const{spec}.
The source code seems somewhat complex: The module spec is defined,
discontinous/1 directives are generated for all leadsto specification terms,
the terms are read from \arg{File} and asserted one by one into the \const{spec}
module.

Command line constants are added to module spec (see \secref{cmdlineconstants}).

Then, the leadsto specification is read one more time, and each Term is
passed on to \handle_term/1.
Most terms are handled by asserting dynamic facts into module algo.
Some of those are 1-1 translations, others don't.

model(Model) is translated into dyn_model(Model),
after checking that there is only one such term.

cwa(F/A) is translated into dyn_cwa(FunctorTerm).

The most interesting things happen with interval like leadsto specification terms.
initialise_interval/3 and inialise_interval_periodic/4 deal with them. These
predicates normalise all interval specification terms into:
dyn_interval(i(Interval, Vars, Form)) and dyn_interval(i(Interval, P, Vars, Form))
facts.

Leadsto rule terms are translated into
dyn_leadsto(I, Vars, LitDisConj, AndLiterals, Delay) facts.

Finally update_sorts/0 performs some pre compilation of sort definitions.

TODO: It is unclear what happeens to sortdefs at this stage. Questions are:
\begin{itemize}
\item
What terms are used? Are they spec:sortdef/2 and spec:sortdef/4?
\item
What is the role of dyn_sortdef/5?
\item
Are constants somehow substituted into sortdef elements?
\end{itemize}
There are question surrounding load_simulation/1:
\begin{itemize}
\item
Why is the leadsto specification scanned twice. The terms will be probably be
walked through even one more time to set up the algorithm.
\end{itemize}
load_simulation/1 sets dyn_sim_status(TraceFile, loaded).

\predicate{reset_sim_info}{0}{}
clears the content of spec together with other run time information.
\predicate{runshowspec}{1}{+Frame}
Two parts, runspec/1 and show_results/2.
runspec/2 should probably be responsible for first setting dyn_sim_status(File, running)
and at the end to dyn_sim_status(File, done).

\predicate{runspec}{1}{+Frame}
If we are dealing with a model, we initialize the output trace common to all
model traces, then for each model instantiation we call runmodel/4 that does runspec1/0
and cleans up after itself for the next runmodel/4.

If there is no model/1, we call runspec1/0 followed by savetrace/1.

\predicate{runspec1}{0}{}
TODO: The code introduces \const{TSetup}, dyn_setup_time/1 that seem to have value identical to start_time. Probably at one time we planned to have some setup time that starts
before start_time, based on the maximum leadsto rule values for \jargon{f} and \jargon{g}.

We had options \const{setup_maxg} and \const{setup_maxfg} for that purpose. But the code says this is not supported.

Apparently start_time and end_time may contain constants. The values are passed through
tr_basic_element(Term, [], TermOut) that will substitute spec:constant(Name, Val)
occurrences.
QUESTION: Is this constant substitution (and variable instantiation) done on an ad hoc basis?
If so, can we improve on that?
In runspec/1 we perform:
setup_rt_intervals/0, setup_unknown_or_cwa/2, setup_leadsto/6 for each leadsto rule
dyn_leadsto/5, get_model_checking_p_rules/0 (??), setup_atom_state_boundaries/0 and finally
do the real reasoning in runspec_rest/0.
\predicate{setup_rt_intervals}{0}{}
For every dyn_interval/1 term we perform init_interval_callbacks/10 where all but the first three arguments are callback variables or callback predicates.

TODO: The setting of the interval rules does some detailed steps such as variable instantiation. Finally this leads to changes to dyn_atom_trace/3.
TODO: It is unclear where what variables become instantiated for the interval rules.

Probably we instantiate the encoded variables separately and later do the substitution
of variables by name. see
\begin{code}
initialise_interval_p(Interval, P, Vars, Form1) :-
	(	instantiate_vars(Vars, VarsInst),
		tr_range(Interval, VarsInst, T1, T2),
		tr_basic_element(P, VarsInst, P1),
		...
\end{code}
TODO: \jargon{modelchecking}? Where that comes in is unclear for now. See \secref{modelchecking}.

But, the result seems to be relatively straightfoward, some initial atom_trace/3 values.
\predicate{setup_leadsto}{6}
Also uses init_interval_callbacks/10. It sets dyn_lt_rule(Id, AnteLits,ConseRId,PVOutC,Delay,RId) 
\predicate{init_interval_callbacks}{10}{TimeInfo, Vars, Forms, TimeInfo1, Vars1,
Forms2, InvalidVars, InvalidTimeInfo, ActPreInstantiated}
is used for setting up interval rules and leadsto rules. Probably instantiates variables,
also takes care of forall/2 terms.

TODO FIRST: Lets first get into the details of this important predicate. After that,
inspect what setup_leadsto/6 does.

\end{description}



Traces are generated by the main algorithm in module algo.
They are internally stored
as dyn_atom_trace(AtomKey, Atom, AtomTrace) facts. For performance reasoning
traces that can no longer play a role in the algorithm are backed up into
dyn_atom_trace_backup/3 facts.



\subssubsection{Saving traces}

Traces are saved in two stages by
\begin{description}
\predicate{savetracesetup}{3}{+File, +Frame, -Telling}
Saves constants and sets up trace storage stream.
\predicate{savetrace1}{1}{+TraceName}
 Saves the trace itself. (If \arg{TraceName} is \const{[]}, trace will
 not have trace id.)
\predicate{savemodelspec_cleanup}{2}{-TellStream,
+ModelInstanceTraceName}
If the \jargon{leadsto specification} contains a model, the separate
model instances saved._
\end{description}

\section{Details}

\subsection{Command line constants}	\label{sec:cmdlineconstants}

From the command line one can specify \const{-constant Name=Value}. This adds a
constant to the specification. Value must be a valid ground Prolog term.

util:set_option_constant/1 handles this by asserting dyn_add_cmd_constant/2.

util:load_cmd_constants/0 loads those constants into module \const{spec} as
\const{constant(Name, Value)} facts.

\subsection{Model Checking} \label{sec:modelchecking}

The source contains code labelled \jargon{model checking}. I do not remember whether
this code ever worked. I seem to remember I tried converting the leadsto model
into some state based form.

\const{Makefile} contains an example call of using modelchecking:
\begin{code}
./leadsto -local -modelchecking spec/heartn.lt
\end{code}
The only visible result seems to be some debugging info on the screen.

A first look at the code in \jargon{modelchecking.pl} does not make anything clear
yet.

\subsection{recwait}

Within algo the two choices for representing algorithm state are mixed too much with
the rest of the code. recwait/0 is the switch between storage as recorded and storage as
a dynamic clause. Sometimes code seems to be copy/pasted almost. But, it seems
that backtracking in the recorded database and backtracking in the asserted
database works differently, see update_activity_times1/1.

\subsection{schedule_fire/3}

What is the reason for schedule_fire/3, why postpone?

\subsection{Following the progress of leadsto rules}

We start with setup_leadsto(TStart, Vars, LitDisConj, AndLiterals, Delay,RId)
where the arguments are almost identical to the values in the Leadsto
specification.

Then init_interval_callbacks/9 transforms some constructs such as forall.
Need to check what happens with variables.

After a number of steps involving normalizing conjunctions and disjunctions and
partial evaluation pruning out true and false results,
setup_lt(Ante, Conse, Vars, Delay, Id, RId) is called.

The encoding of the antecedent is responsible for generating code. If a
Term is a comparison operator, code is generated for that, if a term is
an arithmetic expression, code is also generated.

We pass on some (incomplete) data structures. code_form/4 uses
ds_d(AnteResult, VarsIn, PVIn) and ds_d(AnteTail, VarsOut, PVOut).
AnteResult is a difference list. Therefor often AnteTail is set to [].

code_form/4 is used for Antecedent and Consequent.

Each AnteConseTerm is translated as a list element in AnteResult.
L = ds_litd(Atom, PosNeg, PreOps, PostOps, PostConds) where
Atom can be true or any other value. It seems that its translated value
is not tested in any way.

Within code_form/4, tr_arg_prolog1(Term, PVIn, Term1, Inst, DSTAIn, DSTAOut)
is used where
\begin{code}
DSTAIn = ds_ta(VIn, PVIn, [], [], []),
...
DSTAOut = ds_ta(VOut, PVOut, PreOpsOut, PostOpsOut, PostCondsOut),
\end{code}
Inst should result in Inst == inst.

tr_arg_prolog1/6 translates leadsto variables into Prolog variables,
their relation is stored and retrieved in PVIn/PVOut, by
var_pl_to_var_list/6 and var_pl_from_var_list/5.

The first encounter of a leadsto variable in a code_form/4 has Inst= next,
a later one gets Inst = inst. Inst values can be inst, next, var, mixed.


tr_arg_prolog1/6 is also responsible for substituting \jargon{spec_constant}s.

TODO: Check whether Atoms could end up as Prolog variables, look at
code_atom/4 where Inst is ignored in the code. Can Inst be var or mixed there?

code_conse(Conse, VOut, PVOut, Id, ConseRId, PVOutC) translates
Conse through code_form/4, but true ConseLits are removed.
(TODO: why not from Ante?).

The consequent is encoded as ds_cr(ConseLits, ds_ri(Id)), but pxor
consequents are treated differently, TODO.

The result is stored as dyn_lt_rule(Id, AnteLits,ConseRId,PVOutC,Delay,RId)
but more important, setup_lt_normed(AnteLits, AnteHolds, TMin, THolds,
ConseRId, PV, Delay, Removed), it leads to setup_lt_wait_var/12.

TODO: Looking at the code, it seems that we do not reorder the AnteLiterals
depending on intermediate results.


\subsection{Handled Time, Setup Time, Start Time}

Handled time is initialized by setup_unknown_or_cwa/2 to TStart.
There is an additional implied condition on handled time:
"You should never ask for values before TSetup" and
"All atoms that have no explicit trace entry before THandled have
value false if cwa, unknown otherwise. Depending on our choice for
TSetup, this defines values at or before TSetup, independent on any 
leadsto rule firing. We should probably ensure that leadsto rules
cannot fire results before TSetup.

\subsection{Focus points}

How are leadsto rules handled? Is there one pointer to the next activity w.r.t.
the rule per instantiation?



