\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\usepackage{plpage}
\sloppy
\makeindex

\onefile
\htmloutput{.}					% Output directory
\htmlmainfile{pldoc}				% Main document file
\bodycolor{white}				% Page colour

\begin{document}

\title{LeadsTo Software}
\author{Lourens van der Meij \\
	E-mail: \email{lourenstcc@gmail.com}}

\maketitle

\begin{abstract}
This document describes the LeadsTo software.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{LeadsTo core design and implementation}

\subsection{Introduction}

A leadsto specification is encoded as a pl file containing predicates. We should
have an exhaustive documentation of all allowed predicates.

Here we describe the main leadsto procedure algo:run_simulation/2.
This leadsto specification is loaded into the leadsto runtime:

\begin{enumerate}

\item
  The predicates are loaded into module called "spec".

\item
  After that, all terms in the input file are preprocessed, often
  leading to asserted dynamic predicates in the current(algo) module.

  There seems to be almost no compilation at this stage and it looks
  like terms in thee spec module often are asserted as facts into algo
  without any transformation.

  Some translation of sortdefs is performed. If a sort contains less
  than 100 ground terms, it is instantiated, otherwise the sort
  definition is left as is. This leads to spec:sortdef(Sort, Terms). The
  source contains a beginning of a new way of encoding sort definitions.

\item

  If the specification contained a model specification, we run each
  model instance after setting up model parameters.
  Otherwise we perform a single run.

\item
Running the specification

\begin{enumerate}
\item
setup of the runtime (first part of runspec1/0)
\item
performing the firing of rules (runspec_rest/0)
\end{enumerate}

\item
Saving the generated trace
\end{enumerate}

\subsection{LeadsTo specifications}

\subsubsection{Sources for information}

The file \url{userman.html} contains the documentation for most allowed
constructs in LeadsTo specifications. Apart from that we will use the
source to check whether there are more features.

There are some problems with the way leadsto constructs are specified.
They are translated into Prolog facts yet we do not put quotes around upper case
atoms.

\begin{code}
model(m1(Delay:between(10, 12))).
interval([], range(0, 1), a).
leadsto([], a, b, efgh(Delay, Delay, 1, 1)).
\end{code}

Here Delay should be quoted. The leadsto terms allowed seem to be relatively
exaustive. Probabilistic constructs are missing though.

\section{Details}

\subsubsection{Times}

\begin{description}
\item[setuptime]
\item[handledtime]
\item[starttime]
\item[endtime] If not specified there currently is a default of 200 (see end_time/1)
\end{description}

Looking at do_setup_time(TStart, TSetup) it looks like TSetup is identical to TStart, although
it may have been foreseen that options setup_maxg and setup_maxfg could lead to the algorithm
starting before TStartup. start_time is only used when refering to traces, in the algorithm
only setuptime is used.

HandledTime is incremented in handled_time_step/1 and runspec_rest/0 ensures that
at the end of the leadsto algorithm handledtime >= Endtime.
\subsection{Traces}

\subsubsection{Datastructures}

Traces are stored as Prolog facts, each fact represents values of a single ground atom.

Values of an atom over time are represented as a list:
 [range(23.0, 24.0, true), range(17, 18, true)].

The ranges are ordered, the latest time range first. During the execution of our
leadsto algorithm, only necessary values are stored, unknown ranges or false ranges
while cwa(Atom) holds are not part of the trace.

In saved traces all values are represented. Saved traces will only contain
atom values in the range start_time to end_time. The leadsto algorithm may derive values
outside of that range.

TODO: We should discuss alternatives:
\begin{enumerate}
\item
Why not save only necessary values in saved traces?
\item
If saving everything, why not compact the timerange?
[range(T1, T2, TFU1), range(T2, T3, TFU3), ...]
into [T1-TFU1, T2-TFU2, .. TE-[]]

\end{enumerate}



\subsubsection{Generation}
Traces are generated by the main algorithm in module algo. They are internally stored
as dyn_atom_trace(AtomKey, Atom, AtomTrace) facts. For performance reasoning
traces that can no longer play a role in the algorithm are backed up into
dyn_atom_trace_backup/3 facts.

\subssubsection{Saving traces}

Traces are saved in two stages by
\begin{description}
\predicate{savetracesetup}{3}{+File, +Frame, -Telling}
Saves constants and sets up trace storage stream.
\predicate{savetrace1}{1}{+TraceName}
 Saves the trace itself. (If \arg{TraceName} is \const{[]}, trace will
 not have trace id.)
\predicate{savemodelspec_cleanup}{2}{-TellStream,
+ModelInstanceTraceName}
If the \jargon{leadsto specification} contains a model, the separate
model instances saved._
\end{description}



