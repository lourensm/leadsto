\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\usepackage{plpage}
\sloppy
\makeindex

\onefile
\htmloutput{.}					% Output directory
\htmlmainfile{pldoc}				% Main document file
\bodycolor{white}				% Page colour

\begin{document}

\title{LeadsTo Software}
\author{Lourens van der Meij \\
	E-mail: \email{lourenstcc@gmail.com}}

\maketitle

\begin{abstract}
This document describes the LeadsTo software.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{LeadsTo core design and implementation}

\subsection{Introduction}

A leadsto specification is encoded as a pl file containing predicates. We should
have an exhaustive documentation of all allowed predicates.

Here we describe the main leadsto procedure algo:run_simulation/2.
This leadsto specification is loaded into the leadsto runtime:

\begin{enumerate}

\item
  The predicates are loaded into module called "spec".

\item
  After that, all terms in the input file are preprocessed, often
  leading to asserted dynamic predicates in the current(algo) module.

  There seems to be almost no compilation at this stage and it looks
  like terms in thee spec module often are asserted as facts into algo
  without any transformation.

  Some translation of sortdefs is performed. If a sort contains less
  than 100 ground terms, it is instantiated, otherwise the sort
definition is left as is. This leads to spec:sortdef(Sort, Terms). The
  source contains a beginning of a new way of encoding sort definitions.

\item

  If the specification contained a model specification, we run each
  model instance after setting up model parameters.
  Otherwise we perform a single run.

\item
Running the specification

\begin{enumerate}
\item
setup of the runtime (first part of runspec1/0)
\item
performing the firing of rules (runspec_rest/0)
\end{enumerate}

\item
Saving the generated trace
\end{enumerate}

\subsection{LeadsTo specifications}

\subsubsection{Sources for information}

The file \file{userman.html} contains the documentation for most allowed
constructs in LeadsTo specifications. Apart from that we will use the
source to check whether there are more features.

There are some problems with the way leadsto constructs are specified there.
They are translated into Prolog facts yet we do not put quotes around upper
case
atoms.

\begin{code}
model(m1(Delay:between(10, 12))).
interval([], range(0, 1), a).
leadsto([], a, b, efgh(Delay, Delay, 1, 1)).
\end{code}

Here Delay should be quoted. The leadsto terms described there seem to be
relatively
complete. Probabilistic constructs are missing though.

\section{Details}

\subsection{Times}

\begin{description}
\item[setuptime]
\item[handledtime]
\item[starttime]
\item[endtime] If not specified there currently is a default of 200 (see end_time/1)
\end{description}

Looking at \exam{do_setup_time(TStart, TSetup)} it looks like \exam{TSetup}
is identical to \exam{TStart}, although
it may have been foreseen that options \prologflag{setup_maxg} and
\prologflag{setup_maxfg} could lead to the algorithm
starting before \exam{TStart}. start_time is only used when referring to
traces, in the algorithm
only \exam{TSetup} is used.

\exam{HandledTime} is incremented in handled_time_step/1 and
runspec_rest/0 ensures that
at the end of the leadsto algorithm \exam{handledtime >= Endtime}.
\subsection{Traces}

\subsubsection{Datastructures}

Traces are stored as Prolog facts, each fact represents values of a single
ground atom.

Values of an atom over time are represented as a list:
 [range(23.0, 24.0, true), range(17, 18, true)].

The ranges are ordered, the latest time range first. During the execution of our
leadsto algorithm, only necessary values are stored, unknown ranges or false
ranges
while \exam{cwa(Atom)} holds are not part of the trace.

In saved traces all values are represented. Saved traces will only contain
atom values in the range start_time to end_time. The leadsto algorithm may derive values
outside of that range.

TODO: We should discuss alternatives:
\begin{enumerate}
\item
Why not save only necessary values in saved traces?
\item
If saving everything, why not compact the timerange?
\exam{[range(T1, T2, TFU1), range(T2, T3, TFU3), ...]}
into \exam{[T1-TFU1, T2-TFU2, .. TE-[]]}

\end{enumerate}


\subsubsection{Variables}

\begin{description}
\predicate{dyn_sim_status}{2}{File, Status}
says in what stage of loading and running the
algo algorithm is. \arg{Status} is \const{loaded}, \const{running} or \const{done}.

\predicate{dyn_currently_loaded}{2}{Kind, File}
says what \arg{File} is loaded and what \arg{Kind}, where \arg{Kind} is \const{trace} or
\arg{sim}.
\end{description}
\subsubsection{Loading and Trace Generation}


\begin{description}
\predicate{load_simulation}{1}{+File}
The specification \arg{File} is loaded into module \const{spec}.
The source code seems somewhat complex: The module spec is defined,
discontinous/1 directives are generated for all leadsto specification terms,
the terms are read from \arg{File} and asserted one by one into the \const{spec}
module.

Command line constants are added to module spec (see \secref{cmdlineconstants}).

Then, the leadsto specification is read one more time, and each Term is
passed on to handle_term/1.
Most terms are handled by asserting dynamic facts into module algo.
Some of those are 1-1 translations, others don't.

model(Model) is translated into dyn_model(Model),
after checking that there is only one such term.

\exam{cwa(F/A)} is translated into \exam{dyn_cwa(FunctorTerm)}.

The most interesting things happen with interval like leadsto specification
terms.
initialise_interval/3 and initialise_interval_periodic/4 deal with them. These
predicates normalise all interval specification terms into:
\exam{dyn_interval(i(Interval, Vars, Form))} and 
\exam{dyn_interval(i(Interval, P, Vars, Form))}
facts.

Leadsto rule terms are translated into
\exam{dyn_leadsto(I, Vars, LitDisConj, AndLiterals, Delay)} facts.

Finally update_sorts/0 performs some pre compilation of sort definitions.

TODO: It is unclear what happeens to sortdefs at this stage. Questions are:
\begin{itemize}
\item
What terms are used? Are they spec:sortdef/2 and spec:sortdef/4?
\item
What is the role of dyn_sortdef/5?
\item
Are constants somehow substituted into sortdef elements?
\end{itemize}
There are question surrounding load_simulation/1:
\begin{itemize}
\item
Why is the leadsto specification scanned twice. The terms will be probably be
walked through even one more time to set up the algorithm.
\end{itemize}
load_simulation/1 sets \exam{dyn_sim_status(TraceFile, loaded)}.

\predicate{reset_sim_info}{0}{}
clears the content of spec together with other run time information.
\predicate{runshowspec}{1}{+Frame}
Two parts, runspec/1 and show_results/2.
runspec/2 should probably be responsible for first setting
\exam{dyn_sim_status(File, running)}
and at the end to \exam{dyn_sim_status(File, done)}.

\predicate{runspec}{1}{+Frame}
If we are dealing with a model, we initialize the output trace common to all
model traces, then for each model instantiation we call runmodel/4 that does runspec1/0
and cleans up after itself for the next runmodel/4.

If there is no model/1, we call runspec1/0 followed by savetrace/1.

\predicate{runspec1}{0}{}
TODO: The code introduces \const{TSetup}, dyn_setup_time/1 that seem to have value identical to start_time. Probably at one time we planned to have some setup time that starts
before start_time, based on the maximum leadsto rule values for \jargon{f} and \jargon{g}.

We had options \const{setup_maxg} and \const{setup_maxfg} for that purpose. But the code says this is not supported.

Apparently start_time and end_time may contain constants. The values are
passed through
\exam{tr_basic_element(Term, [], TermOut)}
that will substitute \exam{spec:constant(Name, Val)}
occurrences.
QUESTION: Is this constant substitution (and variable instantiation) done on an ad hoc basis?
If so, can we improve on that?
In runspec/1 we perform:
setup_rt_intervals/0, setup_unknown_or_cwa/2, setup_leadsto/6 for each leadsto rule
dyn_leadsto/5, get_model_checking_p_rules/0 (??), setup_atom_state_boundaries/0 and finally
do the real reasoning in runspec_rest/0.
\predicate{setup_rt_intervals}{0}{}
For every dyn_interval/1 term we perform init_interval_callbacks/10 where all but the first three arguments are callback variables or callback predicates.

TODO: The setting of the interval rules does some detailed steps such as variable instantiation. Finally this leads to changes to dyn_atom_trace/3.
TODO: It is unclear where what variables become instantiated for the interval rules.

Probably we instantiate the encoded variables separately and later do the substitution
of variables by name. see
\begin{code}
initialise_interval_p(Interval, P, Vars, Form1) :-
	(	instantiate_vars(Vars, VarsInst),
		tr_range(Interval, VarsInst, T1, T2),
		tr_basic_element(P, VarsInst, P1),
		...
\end{code}
TODO: \jargon{modelchecking}? Where that comes in is unclear for now. See \secref{modelchecking}.

But, the result seems to be relatively straightfoward, some initial atom_trace/3 values.
\predicate{setup_leadsto}{6}
Also uses init_interval_callbacks/10. It sets
\exam{dyn_lt_rule(Id, AnteLits,ConseRId,PVOutC,Delay,RId)} 
\predicate{init_interval_callbacks}{10}{TimeInfo, Vars, Forms, TimeInfo1, Vars1,
Forms2, InvalidVars, InvalidTimeInfo, ActPreInstantiated}
is used for setting up interval rules and leadsto rules. Probably instantiates
variables,
also takes care of forall/2 terms.

TODO FIRST: Lets first get into the details of this important predicate. After that,
inspect what setup_leadsto/6 does.

\end{description}



Traces are generated by the main algorithm in module algo.
They are internally stored
as \exam{dyn_atom_trace(AtomKey, Atom, AtomTrace)} facts. For performance reasoning
traces that can no longer play a role in the algorithm are backed up into
dyn_atom_trace_backup/3 facts.



\subsubsection{Saving traces}

Traces are saved in two stages by
\begin{description}
\predicate{savetracesetup}{3}{+File, +Frame, -Telling}
Saves constants and sets up trace storage stream.
\predicate{savetrace1}{1}{+TraceName}
 Saves the trace itself. (If \arg{TraceName} is \const{[]}, trace will
 not have trace id.)
\predicate{savemodelspec_cleanup}{2}{-TellStream,
+ModelInstanceTraceName}
If the \jargon{leadsto specification} contains a model, the separate
model instances saved._
\end{description}

\section{Details}

\subsection{Command line constants}	\label{sec:cmdlineconstants}

From the command line one can specify \const{-constant Name=Value}. This adds a
constant to the specification. Value must be a valid ground Prolog term.

util:set_option_constant/1 handles this by asserting dyn_add_cmd_constant/2.

util:load_cmd_constants/0 loads those constants into module \const{spec} as
\const{constant(Name, Value)} facts.

\subsection{Model Checking} \label{sec:modelchecking}

The source contains code labelled \jargon{model checking}. I do not remember
whether
this code ever worked. I seem to remember I tried converting the leadsto model
into some state based form.

\const{Makefile} contains an example call of using modelchecking:
\begin{code}
./leadsto -local -modelchecking spec/heartn.lt
\end{code}
The only visible result seems to be some debugging info on the screen.

A first look at the code in \jargon{modelchecking.pl} does not make anything
clear yet.

There is a document modelchecking.doc that should provide some background.
I fear that the code that is still present in algo.pl never really did
anything.

\subsection{recwait}

Within algo the two choices for representing algorithm state are mixed too much with
the rest of the code. recwait/0 is the switch between storage as recorded and storage as
a dynamic clause. Sometimes code seems to be copy/pasted almost. But, it seems
that backtracking in the recorded database and backtracking in the asserted
database works differently, see update_activity_times1/1.

\subsection{schedule_fire/3}

What is the reason for schedule_fire/3, why postpone?

\subsection{Following the progress of leadsto rules}

We start with setup_leadsto(TStart, Vars, LitDisConj, AndLiterals, Delay,RId)
where the arguments are almost identical to the values in the Leadsto
specification.

Then init_interval_callbacks/9 transforms some constructs such as forall.
Need to check what happens with variables.

After a number of steps involving normalizing conjunctions and disjunctions and
partial evaluation pruning out true and false results,
setup_lt(Ante, Conse, Vars, Delay, Id, RId) is called.

The encoding of the antecedent is responsible for generating code. If a
Term is a comparison operator, code is generated for that, if a term is
an arithmetic expression, code is also generated.

We pass on some (incomplete) data structures. code_form/4 uses
ds_d(AnteResult, VarsIn, PVIn) and ds_d(AnteTail, VarsOut, PVOut).
AnteResult is a difference list. Therefor often AnteTail is set to [].

code_form/4 is used for Antecedent and Consequent.

Each AnteConseTerm is translated as a list element in AnteResult.
L = ds_litd(Atom, PosNeg, PreOps, PostOps, PostConds) where
Atom can be true or any other value. It seems that its translated value
is not tested in any way.

Within code_form/4, tr_arg_prolog1(Term, PVIn, Term1, Inst, DSTAIn, DSTAOut)
is used where
\begin{code}
DSTAIn = ds_ta(VIn, PVIn, [], [], []),
...
DSTAOut = ds_ta(VOut, PVOut, PreOpsOut, PostOpsOut, PostCondsOut),
\end{code}
Inst should result in Inst == inst.

tr_arg_prolog1/6 translates leadsto variables into Prolog variables,
their relation is stored and retrieved in PVIn/PVOut, by
var_pl_to_var_list/6 and var_pl_from_var_list/5.

The first encounter of a leadsto variable in a code_form/4 has Inst= next,
a later one gets Inst = inst. Inst values can be inst, next, var, mixed.


tr_arg_prolog1/6 is also responsible for substituting \jargon{spec_constant}s.

TODO: Check whether Atoms could end up as Prolog variables, look at
code_atom/4 where Inst is ignored in the code. Can Inst be var or mixed there?

code_conse(Conse, VOut, PVOut, Id, ConseRId, PVOutC) translates
Conse through code_form/4, but true ConseLits are removed.
(TODO: why not from Ante?).

The consequent is encoded as ds_cr(ConseLits, ds_ri(Id)), but pxor
consequents are treated differently, TODO.

The result is stored as dyn_lt_rule(Id, AnteLits,ConseRId,PVOutC,Delay,RId)
but more important, setup_lt_normed(AnteLits, AnteHolds, TMin, THolds,
ConseRId, PV, Delay, Removed), it leads to setup_lt_wait_var/12.

A number of facts:
\begin{itemize}
\item
If AnteLits becomes \const{[]}, setup_lt_conse(AnteHolds, TMin, THolds, ConseRId, Delay, Removed) is called. If $THolds >= TMin + G$, we calculate $ T3 is  TMin + G + Delay$ and
$T4 is THolds + Delay + H$ and then do schedule_fire(ConseRId, T3, T4) which sets
dyn_schedule_fire(ConseRId, T3, T4).\footnote{I left out details dealing with pxor aspects.}
They are fired by the \exam{repeat, set_state, handle_fired} sequence in runspec_rest/0.~\footnote{Why not fire immediately?}
After schedule_fire/3 we do setup_lt_wait_fired/6. If $THolds < TMin + G$ we do
setup_lt_wait_true/5.

setup_lt_wait_fired stores a wait_fired/5 fact.~\footnote(It is confusing that two implementations of this waiting are present in the code, depending on the recwait/0 switch.
\item
We need to study the FV, FVL aspects in more detail.
\end{itemize}


TODO: Looking at the code, it seems that we do not reorder the AnteLiterals
depending on intermediate results.


\subsection{Handled Time, Setup Time, Start Time}

Handled time is initialized by setup_unknown_or_cwa/2 to TStart.
There is an additional implied condition on handled time:
"You should never ask for values before TSetup" and
"All atoms that have no explicit trace entry before THandled have
value false if cwa, unknown otherwise. Depending on our choice for
TSetup, this defines values at or before TSetup, independent on any 
leadsto rule firing. We should probably ensure that leadsto rules
cannot fire results before TSetup.

\subsection{Focus points}

How are leadsto rules handled? Is there one pointer to the next activity w.r.t.
the rule per instantiation?

\section{Working backwards}
Meaning, trying to reconstruct the algorithm from the start.

\subsection{Aspects}

We limited e, f, g, h:\exam{e,f, g, h >= 0} and if \exam{h == 0} then  \exam{g} must be 0. But 
also,
\exam{e + f + g + h > 0}. Why those requirements? We probably do not want to reason without delay.

e, f, g, h:
Once an antecedent holds for duration \const{g} + T, a delay is set between e and f, and
the antecedent will hold during \const{h} + T. So, even if a rule has fired, we need to 
remember that it has fired and as long as the antecedent may continue to hold, the consequent
will be propagated for a longer time.


\subsection{Invariant}

\exam{HandledTime}: Everything that can be derived, has been derived for 
\exam{T <= HandledTime}.  
CWA atom values do not have to be instantiated, probably will not be instantiated to false
values.

\subsection{Sketch of the algorithm}

All rules that could still fire are inspected, their antecedent effect is exhaustively tested 
up to HandledTime at least. 

After everything has fired, we inspect all waiting antecedents, and look at time
their first result could come in. And the minimum value becomes the next HandledTime, unless
this minimum value is not after HandledTime (could it be smaller?). It looks like the
algorithm currently simply gives up if there is a rule that could fire at HandledTime.

It is probably important that together with setting HandledTime, every rule that
has some continuation has its effect propagated till the new HandledTime. 

This would make the invariant more precise: Every rule has its state updated
in such a way that the antecedents have been checked up to the new HandledTime.

\subsection{Rule States}

Rules can contain variables, that is, antecedent literals can have variables.
There can be more than one separate states per rule.

It could be that the first N literals of the antecedent with some specific 
instantiation
are valid in some time range T1 - T2. 

We will look strictly left to right.

But, the extending of the fired rules is done in reverse, why? Probably because
we wish to extend the range as far as possible.

\subsection{Garbage collection}

Is complex and not documented. In the source some explanation is given,
bugdev.txt also contains some explanation.

\subsection{Understanding}

setup_lt_notground_fv analyses the current LitData first for all AtomTraces 
and all cwa matches, handles those separately by check_fire_isolated or setup_lt_normed.

Finally setup_wait_var is called with Atom, FV, FVL values implying that FV 
from FVL has been handled, but we need to check other instantiations.

setup_lt_notground_fv(TStart, FV, FVL, LitData, ToDoAnte, AnteHolds,THolds,
		      ConseRId,PV,Delay, Id, IdTerm, Removed):
AnteHolds holds for Time Interval between TStart and THolds. ToDoAnte is the conjunction that needs to hold.
LitData is the Literal under investigation. FV are the free variables of the Literal and FVL is a list
of instantiations that have been dealt with elsewhere.

Delay is efgh(E,F,G,H), ConseRId is the consequent.

Removed indicates the source of the call. In case ofupdate_activity_time1(wait_var...), the
wait_var  term is Removed and the Removed is propagated along.

PV is probably the characterization of the  variables:pv(Arga, Sorta,Kinda,Arg1a).

setup_lt_notground_fv is called by setup_lt_notground, by setup_lt_normed, by setup_lt.
setup_lt is called from setup_nontrivial_leadsto.
setup_lt_normed is also called by instantiate_op and fail_filter_handleRR.

We probably handle the rule in this call up to HandledTime.

Now, if at the call THolds < HandledTime, we start all over, for this partially 
instantiated sequence
of literals by calling get_new_tholds. Apparently the order of literals is reversed here.
get_new_tholds is called here and by get_new_tholds itself.
get_new_tholds(AnteHoldsTODO, AHDone, TStart, THoldsNew1, Tholds,FV, FVL, LitData, 
ToDoAnte, ConseRId,PV,Delay, Id,IdTerm,Removed):
AnteHoldsTODO is an earlier instantiated sequence of literals that needs to be extended 
in range up to
THandled (or further?). AHDone is the sequence that has been checked and hold between 
TStart and THoldsNew1.
Tholds is the result. TODO: Details of Tholds, is this a return parameter?

Be aware that in get_new_tholds the Atom in [ds_lh(lit(Atom,PN),Id1,IdTerm1)|AnteHoldsTODO] is ground, 
and has nothing to
do with FV and FVL.

First, if AnteHoldsTODO == [], we continue with setup_lt_notground_fv with the 
increased interval.
Otherwise we follow AnteHoldsTODO Literals.
NEXT: What does find_min_range_ground(Atom, PN, Tholds, O2) do? Probably: Inspect 
Literal starting from Tholds.




setup_lt_wait_var(FV, FVL, LitData, ToDoAnte, AnteHolds,
			  TMin, THolds, ConseRId, PV, Delay, Id, IdTerm):

Probably: We know AnteHolds is ok between TMin and THolds.
LitData is the current literal that has been analyzed. FV are the free variables in the 
Literal, FVL is the list of instantiations of FV that have been dealt with, for which 
this setup is not responsible at all. Called by setup_lt_notground1default/12 ( same 
arguments) which is only called as last call in 
setup_lt_notground_fv/13.

TODO: Really nail down the meaning of wait_var, also at what stage are what values for TMin and THolds set.
TODO: Will wait_vars become invalidated? Inspect get_new_tholds.

\section{So far}

Try documenting the whole data structure that describes the state of each leadsto
rule first. All invariants, the understanding of having every possible 
outcome of a leadsto rule represented.

At what stage the HandledTime invariant is. Understanding the get_new_tholds,
the reverse is on purpose as that is part of the invariant, having a partial
instantiation left to right.

After that, try understanding the cleanup efforts of wait_var.

BUT: start describing in detail. Look at what I did so far, can I reuse documentation.
Step1: Can leadsto.doc be printed out?

\section{"Syntax" of Leadsto Specifications}

Copied from syntax.txt:
\begin{code}
The leadsto input syntax is prolog syntax, but with the
following added/changed operator definitions.
(For input of leadsto specs in prolog, the : redefinition is 
 awkward. I do a push/pop operator call for reading)

			op(150, xfx, :),
			op(700, xfy, <),
			op(700, xfy, <=),
			op(700, xfy, =<),
			op(700, xfy, >),
			op(700, xfy, >=)
			]).

Currently, only the top level terms are described. I am working
on syntax (+minimal explanation of semantics) of the top level
terms, but especially the sub terms.

sub terms:

% VAR:PLPCE:
    VAR, in principle, a prolog term, although Uppercase atoms 
    are allowed. Quotes around atoms are allowed.
     TODO: are unquoted uppercase functors allowed?
     e.g. P(a) TODO: what are further restrictions and 
     interpretations of PLPCE terms TODO: junk this stupid 
     name "PLPCE".

% start_time(PLPCE)
% end_time(PLPCE)
% global_lambda(PLPCE)


TODO: why those qterms?
% qterm(cwa(X))        cwa_node 
% qterm(external(X))   external_node
% qterm(X) ...         other_node

% display(_,_)
% display_number_range(_,_,_,_)

% periodic(Vars, Range, Period:PLPCE, Formula) is_list(Vars)
		 * handle_interval(Vars, Range, Formula, Root, Son, Extra)
% periodic(ST, ET, Period:PLPCE, Formula)
	         * handle_interval([], range(ST, ET), Formula, Root,Son,Extra),
% periodic(Vars, ST, ET, Period:PLPCE, Formula)
		 * handle_interval(Vars, range(ST, ET),Formula,Root,Son,Extra)
% interval(Vars, ST, ET, Formula)
		 * handle_interval(Vars, Range, Formula, Root, _Son, Extra)
% interval(Vars, ST, ET, Formula)
		 * handle_interval(Vars, range(ST, ET),Formula,Root,_Son,Extra)
% interval(ST, ET, Formula)
		 * handle_interval([], range(ST, ET), Formula,Root,_Son,Extra)

% leadsto(AnteFormula, ConseFormula, Delay)
	* handle_leadsto1(Root, AnteFormula, ConseFormula, Delay, Extra, _Son)
% leadsto(Vars, AnteFormula, ConseFormula, Delay)
	* handle_leadsto1(Root, AnteFormula, ConseFormula, Delay, Extra, Son)
% specification(_) 
		   * IGNORED
% content(C)
		* TODO? assertz(dyn_content(C))
% denotes(Header, Formula)
		  * term_to_formula_node(Formula, FormulaNode, Extra),
		new(PN, property_def_node(@off)),
		send(PN, fill_header, Header),
		send(PN, son, FormulaNode),
		send(Root, son, PN)
% (sort_element(SortName:PLPCE, Term):- member(Term2, List) with Term==Term2
		* test_sort_def(SortName, List, Extra),
	ensure_sort_son(Root, SortName1, SNode),
	add_sort_contents(SNode, List).
% constant(Name, Value)
  * check_constant(Name, Value),
	send(Root, son, new(N, constant_def_node)),
	send(N, fill_header, Name),
	send(N, fill_value, Value)
% sortdef(SortName:PLPCE, Objs)
  * test_sort_def(SortName, Objs, Extra),
	send(Root, son, new(SN, sort_node)),
	send(SN, change_gui_prop, sort_name, SortName1),
	add_sort_contents(SN, Objs).
% cwa(PLPCE)
% model(PLPCE)
% [specification_element] 
  * generic node
\end{code}
\end{document}
