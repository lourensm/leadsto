\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\usepackage{plpage}
\sloppy
\makeindex

\onefile
\htmloutput{.}					% Output directory
\htmlmainfile{pldoc}				% Main document file
\bodycolor{white}				% Page colour

\begin{document}

\title{LeadsTo Software}
\author{Lourens van der Meij \\
	E-mail: \email{lourenstcc@gmail.com}}

\maketitle

\begin{abstract}
This document describes the LeadsTo software in detail. It starts out as an investigation
into details of the algorithm.

\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{LeadsTo core design and implementation}

\subsection{Introduction}

A leadsto specification is encoded as a pl file containing predicates.

\subsection{run_simulation/2}

Here we describe the main leadsto procedure run_simulation/2,
\exam{run_simulation(File, Frame)}
This leadsto specification \arg{File} is loaded into the leadsto runtime:

\begin{enumerate}

\item
  The predicates are loaded into module \exam{spec}.

\item
  After that, all terms in the input file are preprocessed, often
  leading to asserted dynamic predicates in the current(algo) module.

  There seems to be almost no compilation at this stage and it looks
  like terms in thee spec module often are asserted as facts into algo
  without any transformation.

  Some translation of sortdefs is performed. If a sort contains less
  than 100 ground terms, it is instantiated, otherwise the sort
definition is left as is. This leads to spec:sortdef(Sort, Terms). The
  source contains a beginning of a new way of encoding sort definitions.

\item

  If the specification contained a model specification, we run each
  model instance after setting up model parameters.
  Otherwise we perform a single run.

\item
Running the specification

\begin{enumerate}
\item
setup of the runtime (first part of runspec1/0)
\item
performing the firing of rules (runspec_rest/0)
\end{enumerate}

\item
Saving the generated trace
\end{enumerate}

\subsection{LeadsTo specifications}

\subsubsection{Sources for information}

The file \file{userman.html} contains the documentation for most allowed
constructs in LeadsTo specifications. 

The file \file{olddoc/syntax.txt} also describes the syntax.
See \secref{ltsyntax}.

\section{Details}

\subsection{Times: Handled Time, Setup Time, Start Time, End Time}

\begin{description}
\item[setuptime, \exam{TSetup}]In practice identical to \exam{TStartup}, but
there are options for defining \exam{TSetup} to have a value before
\exam{TStart} so that leadsto rules could fire for antecedent values before
\exam{TStart} and use \exam{cwa(Atom)} derived values to make them fire.
The current value of \exam{TSetup} is stored in
\exam{dyn_setup_time(TSetup)}.~\footnote{
We had command line options \const{setup_maxg} and \const{setup_maxfg} for that
purpose that would introduce \exam{TSetup} based on the maximum leadsto rule values for \jargon{f} and \jargon{g}.
But the sourcecode says this is not supported. 
So, in practice
\exam{TStart == TSetup}
}
\item[handledtime]Handled time is initialized by setup_unknown_or_cwa/2 to TStart.
There is an additional implied condition on handled time:
"You should never ask for values before TSetup" and
"All atoms that have no explicit trace entry before THandled have
value false if cwa, unknown otherwise".
\item[starttime, \exam{TStart}] Start time. The algorithm uses \exam{TSetup},
but \exam{TStart} still plays a role, when storing traces, only values
at/after \exam{TStart} are saved.~\footnote{TODO:check this!}
\exam{TStart} is stored as
\exam{dyn_start_time(TStart)}, but only called through start_time/1.

\item[endtime] If not specified there currently is a default of 200 (see end_time/1)
\end{description}

\exam{TSetup} and \exam{TSetup} are set up in
\exam{do_setup_time(TStart, TSetup)}. They may contain specification
constants.~\footnote{In do_setup_times/2 the values are
passed through
\exam{tr_basic_element(Term, [], TermOut)}
that will substitute \exam{spec:constant(Name, Val)}
occurrences. See \secref{constants}.}

\exam{HandledTime} is incremented in handled_time_step/1 and
runspec_rest/0 ensures that
at the end of the leadsto algorithm \exam{HandledTime >= Endtime}.

\subsection{Traces}

\subsubsection{Datastructures}

Traces are stored as Prolog facts, each fact represents values of a single
ground atom.

Values of an atom over time are represented as a list:
\begin{code}
[range(23.0, 24.0, true), range(17, 18, true)]
\end{code}

The ranges are ordered, the latest time range first. During the execution of our
leadsto algorithm, only necessary values are stored, unknown ranges or false
ranges
where \exam{cwa(Atom)} holds are not part of the trace.

In saved traces all values are represented. Saved traces will only contain
atom values in the range \exam{start_time} to \exam{end_time}. The leadsto
algorithm may
derive values outside of that range.~\footnote{
       TODO: We should discuss alternatives:
       \begin{enumerate}
       \item
       Why not save only necessary values in saved traces?
       \item
       If saving everything, why not compact the timerange?
       \exam{[range(T1, T2, TFU1), range(T2, T3, TFU3), ...]}
       into \exam{[T1-TFU1, T2-TFU2, .. TE-[]]}
       \end{enumerate}
}

\subsubsection{Algorithm Variables}

\begin{description}
\predicate{dyn_sim_status}{2}{File, Status}
says in what stage of loading and running the
algo algorithm is. \arg{Status} is \const{loaded}, \const{running} or \const{done}.

\predicate{dyn_currently_loaded}{2}{Kind, File}
says what \arg{File} is loaded and what \arg{Kind}, where \arg{Kind} is \const{trace} or
\const{sim}.
\end{description}


\subsubsection{Loading and Trace Generation}


\begin{description}
\predicate{load_simulation}{1}{+File}
The specification \arg{File} is loaded into module \exam{spec}.
The source code seems somewhat complex: The module \exam{spec} is set up,
discontinous/1 directives are generated for all leadsto specification terms,
the terms are read from \arg{File} and asserted one by one into the \const{spec}
module.

Command line constants are added to module spec (see \secref{constants}).

Then, the leadsto specification is read one more time, and each \exam{Term} is
passed on to handle_term/1.
Most terms are handled by asserting dynamic facts into module \exam{algo}.
Some of those are 1-1 translations, others don't.

\exam{model(Model)} is translated into \exam{dyn_model(Model)},
after checking that there is only one such term.

\exam{cwa(F/A)} is translated into \exam{dyn_cwa(FunctorTerm)}.

The most interesting things happen with interval like leadsto specification
terms.
initialise_interval/3 and initialise_interval_periodic/4 deal with them. These
predicates normalise all interval specification terms into:
\exam{dyn_interval(i(Interval, Vars, Form))} and 
\exam{dyn_interval(i(Interval, P, Vars, Form))}
facts.

Leadsto rule terms are translated into
\exam{dyn_leadsto(I, Vars, LitDisConj, AndLiterals, Delay)} facts.

Finally update_sorts/0 performs some pre compilation of sort definitions.
\footnote{
TODO: It is unclear what happens to sortdefs at this stage. Questions are:
\begin{itemize}
\item
What terms are used? Are they spec:sortdef/2 and spec:sortdef/4?
\item
What is the role of dyn_sortdef/5?
\item
Are constants somehow substituted into sortdef elements?
\end{itemize}
Question surrounding load_simulation/1:
\begin{itemize}
\item
Why is the leadsto specification scanned twice. The terms will be probably be
walked through even one more time to set up the algorithm.
\end{itemize}
}

load_simulation/1 sets \exam{dyn_sim_status(File, loaded)}.

\predicate{reset_sim_info}{0}{}
clears the content of spec together with other run time information.
\predicate{runshowspec}{1}{+Frame}
Two parts, runspecdo/1 and show_results/2.

\predicate{runspecdo}{1}{+Frame}
(Functionality in runspec/1).
If we are dealing with a model, we initialize the output trace common to all
model traces, then for each model instantiation we call runmodel/4 that does
runspec1/0
and cleans up after itself for the next runmodel/4.

If there is no model/1, we call runspec1/0 followed by savetrace/1.

\predicate{runspec1}{0}{}
This procedure calls do_setup_time/2 that sets up \exam{TSetup} and
\exam{TStart}.


In runspec/1 we perform:
setup_rt_intervals/0, setup_unknown_or_cwa/2, setup_leadsto/6 for each
leadsto rule
dyn_leadsto/5, get_model_checking_p_rules/0 (??), setup_atom_state_boundaries/0 and finally
do the real reasoning in runspec_rest/0.

\predicate{setup_rt_intervals}{0}{}
For every dyn_interval/1 term we perform init_interval_callbacks/10 where all but
the first three arguments are callback variables or callback predicates.

The setting of the interval rules does some detailed steps such as variable
instantiation. Finally this leads to changes to dyn_atom_trace/3. See
\begin{code}
initialise_interval_p(Interval, P, Vars, Form1) :-
	(	instantiate_vars(Vars, VarsInst),
		tr_range(Interval, VarsInst, T1, T2),
		tr_basic_element(P, VarsInst, P1),
		...
\end{code}


\predicate{setup_leadsto}{6}
Also uses init_interval_callbacks/10. It sets
\exam{dyn_lt_rule(Id, AnteLits,ConseRId,PVOutC,Delay,RId)} 
\predicate{init_interval_callbacks}{10}{TmInf, Vars, Forms, TmInf1, Vars1,
Forms2, InvldVars, InvldTimeInfo, ActPreInsttiated}
is used for setting up interval rules and leadsto rules. It instantiates
variables, also takes care of forall/2 terms( instantiates them).

\end{description}



Traces are generated by the main algorithm in module algo.
They are internally stored
as \exam{dyn_atom_trace(AtomKey, Atom, AtomTrace)} facts.
For performance reasoning
traces that can no longer play a role in the algorithm are backed up into
dyn_atom_trace_backup/3 facts.~\footnote{TODO:I seem to remember that at places
in the algorithm we depend on there either being dyn_atom_trace/3 or
dyn_atom_trace_backup/3.}




\subsubsection{Saving traces}

Traces are saved in two stages by
\begin{description}
\predicate{savetracesetup}{3}{+File, +Frame, -Telling}
Saves constants and sets up trace storage stream.
\predicate{savetrace1}{1}{+TraceName}
 Saves the trace itself. (If \arg{TraceName} is \const{[]}, trace will
 not have trace id.)
\predicate{savemodelspec_cleanup}{2}{-TellStream,
+ModelInstanceTraceName}
If the \jargon{leadsto specification} contains a model, the separate
model instances saved.
\end{description}

\section{Details}

\subsection{Constants}	\label{sec:constants}

One can define \jargon{specification constants} constants that will be substituted
into leadsto specification elements. Within a leadsto specification we use:
\begin{code}
constant(Name, Value).
\end{code}


From the command line one can specify \const{-constant Name=Value}. This adds a
constant to the specification. Value must be a valid ground Prolog term.

\exam{set_option_constant/1} handles this by asserting \exam{dyn_add_cmd_constant/2}.

util:load_cmd_constants/0 loads those constants into module \const{spec} as
\const{constant(Name, Value)} facts.

Constants are substituted by the procedure
\exam{tr_basic_element(Term, [], TermOut)}. Constants are stored as
\exam{spec:constant(Name, Val)} values.

\subsection{Model Checking} \label{sec:modelchecking}

The source contains code labelled \jargon{model checking}. I do not remember
whether
this code ever worked. I seem to remember I tried converting the leadsto model
into some state based form.

\const{Makefile} contains an example call of using modelchecking:
\begin{code}
./leadsto -local -modelchecking spec/heartn.lt
\end{code}
The only visible result seems to be some debugging info on the screen.

A first look at the code in \jargon{modelchecking.pl} does not make anything
clear yet.

There is a document \file{olddocs/modelchecking.doc} that may provide background.
I fear that the code that is still present in \file{algo.pl} never really did
anything.

\subsection{recwait}

Within algo the two choices for representing algorithm state are mixed too much with
the rest of the code. recwait/0 is the switch between storage as recorded and storage as
a dynamic clause. Sometimes code seems to be copy/pasted. But, it seems
that backtracking in the recorded database and backtracking in the asserted
database works differently, see update_activity_times1/1.

\subsection{schedule_fire/3}

What is the reason for schedule_fire/3, why postpone?

\subsection{Following the progress of leadsto rules}

We start with setup_leadsto/6 where the arguments are almost identical to the
values in the Leadsto specification. 
\begin{description}
\predicate{setup_leadsto}{6}{TStart, Vars, LitDisConj, AndLiterals,
Delay,RId}
where the arguments are almost identical to the values in the Leadsto
specification. Then init_interval_callbacks/9 transforms some constructs
such as forall.

After a number of steps involving normalizing conjunctions and
disjunctions~\footnote{TODO:Verify whether disjunction is allowed} and
partial evaluation pruning out true and false results, setup_lt/6 is called.


\predicate{setup_lt}{6}{Ante, Conse, Vars, Delay, Id, RId}

The encoding of the antecedent is responsible for generating code. If a
Term is a comparison operator, code is generated for that, if a term is
an arithmetic expression, code is also generated.

We pass on some (incomplete) data structures within setup_lt/6. code_form/4 uses
\exam{ds_d(AnteResult, VarsIn, PVIn)} and \exam{ds_d(AnteTail, VarsOut, PVOut)}.
\exam{AnteResult} is a difference list. Therefore often \exam{AnteTail} is set to \exam{[]}.

\predicate{code_form}{4}{+AnteConse, +PosNeg:[pos, neg], DIn, DOut}

code_form/4 is used for \exam{Ante} and \exam{Conse}.

Each \exam{AnteConseTerm} is translated as a list element in \exam{AnteResult}.
\exam{L = ds_litd(Atom, PosNeg, PreOps, PostOps, PostConds)} where
\exam{Atom} can be true or any other value. It seems that its translated value
is not tested in any way.

Within code_form/4, \exam{tr_arg_prolog1(Term, PVIn, Term1, Inst, DSTAIn,
DSTAOut)} is used where
\begin{code}
DSTAIn = ds_ta(VIn, PVIn, [], [], []),
...
DSTAOut = ds_ta(VOut, PVOut, PreOpsOut, PostOpsOut, PostCondsOut),
\end{code}
Inst should result in \exam{Inst == inst}.

\predicate{tr_arg_prolog1}{6}{Term, PVIn, Term1, Inst, DSTAIn,
DSTAOut}

tr_arg_prolog1/6 translates leadsto variables into Prolog variables,
their relationship is stored and retrieved in \exam{PVIn/PVOut}, by
var_pl_to_var_list/6 and var_pl_from_var_list/5.

The first encounter of a leadsto variable in a code_form/4 has
\exam{Inst= next},
a later one gets \exam{Inst = inst}. Inst values can be \exam{inst},
\exam{next}, \exam{var}, \exam{mixed}.


tr_arg_prolog1/6 is also responsible for substituting \jargon{spec_constant}s.~\footnote{TODO: Check whether Atoms could end up as Prolog variables, look at
code_atom/4 where \exam{Inst} is ignored in the code. Can \exam{Inst} be
\exam{var} or \exam{mixed} there?}

\predicate{code_conse}{6}{Conse, VOut, PVOut, Id, ConseRId, PVOutC} translates
\exam{Conse} through code_form/4, but true \exam{ConseLits} are removed.~\footnote{(TODO: why not from Ante?).}

The consequent is encoded as \exam{ds_cr(ConseLits, ds_ri(Id))}, but pxor
consequents are treated differently.~\footnote{TODO}.

The result is stored as \exam{dyn_lt_rule(Id, AnteLits,ConseRId,PVOutC,Delay,RId)}
but more important, \exam{setup_lt_normed(AnteLits, AnteHolds, TMin, THolds,
ConseRId, PV, Delay, Removed)}, it leads to setup_lt_wait_var/12.
\end{description}



A number of facts:
\begin{itemize}
\item
If \exam{AnteLits} becomes \exam{[]}, \\
\exam{setup_lt_conse(AnteHolds, TMin, THolds, ConseRId, Delay, Removed)} is called. If \exam{THolds >= TMin + G}, we calculate
\exam{T3 is  TMin + G + Delay} and
\exam{T4 is THolds + Delay + H} and then call
\exam{schedule_fire(ConseRId, T3, T4)} which sets
\exam{dyn_schedule_fire(ConseRId, T3, T4)}.~\footnote{I left out details dealing
with pxor aspects.}
They are fired by the \exam{repeat, set_state, handle_fired} sequence in runspec_rest/0.~\footnote{Why not fire immediately?}
After schedule_fire/3 we do setup_lt_wait_fired/6. If \exam{THolds < TMin + G}
we call setup_lt_wait_true/5.

\exam{setup_lt_wait_fired} stores a wait_fired/5
fact.~\footnote{It is confusing that two implementations of this waiting are
present in the code, depending on the recwait/0 switch.}
\item
We need to study the \exam{FV}, \exam{FVL} aspects in more detail.
\end{itemize}


TODO: Looking at the code, it seems that we do not reorder the \exam{AnteLiterals}
depending on intermediate results.


\section{Working backwards}

Meaning, trying to reconstruct the algorithm from the start.

\subsection{Leadsto times \exam{e}, \exam{f}, \exam{g}, \exam{h}}

We limited \exam{e}, \exam{f},
\exam{g}, \exam{h}:\exam{e,f, g, h >= 0} and if \exam{h == 0} then
\exam{g} must be 0. But 
also,
\exam{e + f + g + h > 0}.~\footnote{Why those requirements? We probably do not want to reason without delay.}

\exam{e, f, g, h}:

Once an antecedent holds for duration \exam{g + T}, a delay is set between \exam{e} and
\exam{f}, and
the antecedent will hold during \exam{h + T}. So, even if a rule has fired, we need to 
remember that it has fired and as long as the antecedent may continue to hold,
the consequent will be propagated for a longer time.


\subsection{Invariant}

\exam{HandledTime}: Everything that can be derived, has been derived for 
\exam{T <= HandledTime}.  
CWA atom values do not have to be instantiated, probably will not be instantiated to false
values.

\subsection{Sketch of the algorithm}

All rules that could still fire are inspected, their antecedent effect is exhaustively
tested 
up to \exam{HandledTime} at least. 

After everything has fired, we inspect all waiting antecedents, and look at time
their first result could come in. And the minimum value becomes the next
\exam{HandledTime}, unless
this minimum value is not after \exam{HandledTime} (could it be smaller?).
It looks like the
algorithm currently simply gives up if there is a rule that could fire at
\exam{HandledTime}.

It is probably important that together with setting \exam{HandledTime}, every rule that
has some continuation has its effect propagated till the new \exam{HandledTime}. 

This would make the invariant more precise: Every rule has its state updated
in such a way that the antecedents have been checked up to the new \exam{HandledTime}.

\subsection{Rule States}

Rules can contain variables, that is, antecedent literals can have variables.
There can be more than one separate states per rule.

It could be that the first N literals of the antecedent with some specific 
instantiation
are valid in some time range \exam{T1 - T2}. 

We will look strictly left to right.

But, the extending of the fired rules is done in reverse, why? Probably because
we wish to extend the range as far as possible.

\subsection{Garbage collection}

Is complex and not documented. In the source some explanation is given,
\file{olddocs/bugdev.txt} also contains some explanation.

\subsection{Understanding}

\jargon{FV}, \jargon{fv} are abreviations of Free Variables (Prolog variables).

setup_lt_notground_fv/13 analyses the current \exam{LitData} first for all
AtomTraces and all cwa matches, handles those separately by \exam{check_fire_isolated}
or \exam{setup_lt_normed}.

Finally \exam{setup_wait_var} is called with \exam{Atom}, \exam{FV}, \exam{FVL}
values implying that \exam{FV} 
from \exam{FVL} has been handled, but we need to check other instantiations.

\begin{description}
\predicate{setup_lt_notground_fv}{13}{TStart, FV, FVL, LitData, ToDoAnte, AnteHolds,THolds, ConseRId,PV,
Delay, Id, IdTerm, Removed}

\arg{AnteHolds} holds for Time Interval between \arg{TStart} and
\exam{THolds}. \exam{ToDoAnte} is the conjunction that needs to hold.
\exam{LitData} is the Literal under investigation. \exam{FV} are the free variables of
the Literal and \exam{FVL} is a list
of instantiations that have been dealt with elsewhere.

\exam{Delay} is \exam{efgh(E,F,G,H)}, \exam{ConseRId} is the consequent.

\exam{Removed} indicates the source of the call. In case of
\exam{update_activity_time1(wait_var...)}, the
\exam{wait_var}  term is Removed and the Removed is propagated along.

\exam{PV} is probably the characterization of the  variables:\exam{pv(Arga, Sorta,Kinda,Arg1a)}.

\exam{setup_lt_notground_fv} is called by \exam{setup_lt_notground}, it by \exam{setup_lt_normed}, it by \exam{setup_lt}.
\exam{setup_lt} is called from \exam{setup_nontrivial_leadsto}.
\exam{setup_lt_normed} is also called by \exam{instantiate_op} and \exam{fail_filter_handleRR}.

We probably handle the rule in this call up to HandledTime.

Now, if at the call \exam{THolds < HandledTime}, we start all over, for this partially 
instantiated sequence
of literals by calling \exam{get_new_tholds}. Apparently the order of literals is
reversed here.
\exam{get_new_tholds} is called here and by \exam{get_new_tholds} itself.

\predicate{get_new_tholds}{15}{AnteHoldsTODO, AHDone, TStart, THoldsNew1, Tholds,FV, FVL, LitData, 
ToDoAnte, ConseRId,PV,Delay, Id,IdTerm,Removed}

\exam{AnteHoldsTODO} is an earlier instantiated sequence of literals that needs to be
extended in range up to
\exam{THandled} (or further?). \exam{AHDone} is the sequence that has been checked and
hold between 
\exam{TStart} and \exam{THoldsNew1}.
\exam{Tholds} is the result.~\footnote{TODO: Details of Tholds, is this a return
parameter?}

Be aware that in \exam{get_new_tholds} the \exam{Atom} in
\exam{[ds_lh(lit(Atom,PN),Id1,IdTerm1)|AnteHoldsTODO]} is ground, 
and has nothing to
do with \exam{FV} and \exam{FVL}.

First, if \exam{AnteHoldsTODO == []}, we continue~\footnote{as \exam{get_new_tholds} is only called by \exam{setup_lt_notground_fv}} with \exam{setup_lt_notground_fv} with
the increased interval.
Otherwise we follow \exam{AnteHoldsTODO} Literals.

NEXT: What does \exam{find_min_range_ground(Atom, PN, Tholds, O2)} do?
Probably: Inspect Literal starting from Tholds.




\predicate{setup_lt_wait_var}{12}{FV, FVL, LitData, ToDoAnte, AnteHolds,
			  TMin, THolds, ConseRId, PV, Delay, Id, IdTerm}

Probably: We know \exam{AnteHolds} is ok between \exam{TMin} and \exam{THolds}.
\exam{LitData} is the current literal that has been analyzed. FV are the free
variables in the Literal, \exam{FVL} is the list of instantiations of FV that
have been dealt with, for which 
this setup is not responsible at all. Called by
setup_lt_notground1default/12 ( same 
arguments) which is only called as last call in 
setup_lt_notground_fv/13.

TODO: Really nail down the meaning of \exam{wait_var}, also at what stage are
what values for \exam{TMin} and \exam{THolds} set.
TODO: Will \exam{wait_vars} become invalidated? Inspect \exam{get_new_tholds}.

\end{description}


\section{So far}

Try documenting the whole data structure that describes the state of each leadsto
rule first. All invariants, the understanding of having every possible 
outcome of a leadsto rule represented.

At what stage the HandledTime invariant is. Understanding the get_new_tholds,
the reverse is on purpose as that is part of the invariant, having a partial
instantiation left to right.

After that, try understanding the cleanup efforts of \exam{wait_var}.


\section{"Syntax" of Leadsto Specifications}~\label{sec:ltsyntax}

Copied from syntax.txt:
\begin{code}
The leadsto input syntax is prolog syntax, but with the
following added/changed operator definitions.
(For input of leadsto specs in prolog, the : redefinition is 
 awkward. I do a push/pop operator call for reading)

			op(150, xfx, :),
			op(700, xfy, <),
			op(700, xfy, <=),
			op(700, xfy, =<),
			op(700, xfy, >),
			op(700, xfy, >=)
			]).

Currently, only the top level terms are described. I am working
on syntax (+minimal explanation of semantics) of the top level
terms, but especially the sub terms.

sub terms:

% VAR:PLPCE:
    VAR, in principle, a prolog term, although Uppercase atoms 
    are allowed. Quotes around atoms are allowed.
     TODO: are unquoted uppercase functors allowed?
     e.g. P(a) TODO: what are further restrictions and 
     interpretations of PLPCE terms TODO: junk this stupid 
     name "PLPCE".

% start_time(PLPCE)
% end_time(PLPCE)
% global_lambda(PLPCE)


TODO: why those qterms?
% qterm(cwa(X))        cwa_node 
% qterm(external(X))   external_node
% qterm(X) ...         other_node

% display(_,_)
% display_number_range(_,_,_,_)

% periodic(Vars, Range, Period:PLPCE, Formula) is_list(Vars)
		 * handle_interval(Vars, Range, Formula, Root, Son, Extra)
% periodic(ST, ET, Period:PLPCE, Formula)
	         * handle_interval([], range(ST, ET), Formula, Root,Son,Extra),
% periodic(Vars, ST, ET, Period:PLPCE, Formula)
		 * handle_interval(Vars, range(ST, ET),Formula,Root,Son,Extra)
% interval(Vars, ST, ET, Formula)
		 * handle_interval(Vars, Range, Formula, Root, _Son, Extra)
% interval(Vars, ST, ET, Formula)
		 * handle_interval(Vars, range(ST, ET),Formula,Root,_Son,Extra)
% interval(ST, ET, Formula)
		 * handle_interval([], range(ST, ET), Formula,Root,_Son,Extra)

% leadsto(AnteFormula, ConseFormula, Delay)
	* handle_leadsto1(Root, AnteFormula, ConseFormula, Delay, Extra, _Son)
% leadsto(Vars, AnteFormula, ConseFormula, Delay)
	* handle_leadsto1(Root, AnteFormula, ConseFormula, Delay, Extra, Son)
% specification(_) 
		   * IGNORED
% content(C)
		* TODO? assertz(dyn_content(C))
% denotes(Header, Formula)
		  * term_to_formula_node(Formula, FormulaNode, Extra),
		new(PN, property_def_node(@off)),
		send(PN, fill_header, Header),
		send(PN, son, FormulaNode),
		send(Root, son, PN)
% (sort_element(SortName:PLPCE, Term):- member(Term2, List) with Term==Term2
		* test_sort_def(SortName, List, Extra),
	ensure_sort_son(Root, SortName1, SNode),
	add_sort_contents(SNode, List).
% constant(Name, Value)
  * check_constant(Name, Value),
	send(Root, son, new(N, constant_def_node)),
	send(N, fill_header, Name),
	send(N, fill_value, Value)
% sortdef(SortName:PLPCE, Objs)
  * test_sort_def(SortName, Objs, Extra),
	send(Root, son, new(SN, sort_node)),
	send(SN, change_gui_prop, sort_name, SortName1),
	add_sort_contents(SN, Objs).
% cwa(PLPCE)
% model(PLPCE)
% [specification_element] 
  * generic node
\end{code}
\end{document}
